import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  require_react
} from "./chunk-YJNMHHGL.js";

// node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize(fn) {
  var cache = {};
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var memoize_browser_esm_default;
var init_memoize_browser_esm = __esm({
  "node_modules/@emotion/memoize/dist/memoize.browser.esm.js"() {
    memoize_browser_esm_default = memoize;
  }
});

// node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js
var is_prop_valid_browser_esm_exports = {};
__export(is_prop_valid_browser_esm_exports, {
  default: () => is_prop_valid_browser_esm_default
});
var reactPropsRegex, index, is_prop_valid_browser_esm_default;
var init_is_prop_valid_browser_esm = __esm({
  "node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js"() {
    init_memoize_browser_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    index = memoize_browser_esm_default(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
    is_prop_valid_browser_esm_default = index;
  }
});

// node_modules/react-animated-numbers/dist/index.js
var require_dist = __commonJS({
  "node_modules/react-animated-numbers/dist/index.js"(exports, module) {
    !function(t, e) {
      if ("object" == typeof exports && "object" == typeof module)
        module.exports = e(require_react());
      else if ("function" == typeof define && define.amd)
        define(["react"], e);
      else {
        var n = "object" == typeof exports ? e(require_react()) : e(t.react);
        for (var s in n)
          ("object" == typeof exports ? exports : t)[s] = n[s];
      }
    }(self, function(t) {
      return (() => {
        "use strict";
        var e = { 297: (e2) => {
          e2.exports = t;
        } }, n = {};
        function s(t2) {
          var i2 = n[t2];
          if (void 0 !== i2)
            return i2.exports;
          var o = n[t2] = { exports: {} };
          return e[t2](o, o.exports, s), o.exports;
        }
        s.n = (t2) => {
          var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
          return s.d(e2, { a: e2 }), e2;
        }, s.d = (t2, e2) => {
          for (var n2 in e2)
            s.o(e2, n2) && !s.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
        }, s.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), s.r = (t2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        };
        var i = {};
        return (() => {
          s.r(i), s.d(i, { default: () => jo });
          var t2 = s(297), e2 = s.n(t2);
          const n2 = (t3) => t3;
          let o = n2, r = n2;
          const a = { some: 0, all: 1 };
          const l = (t3) => /^\-?\d*\.?\d+$/.test(t3), u = (t3) => /^0[^.\s]+$/.test(t3), c = (t3) => Array.isArray(t3);
          function h(t3, e3) {
            -1 === t3.indexOf(e3) && t3.push(e3);
          }
          function d(t3, e3) {
            const n3 = t3.indexOf(e3);
            n3 > -1 && t3.splice(n3, 1);
          }
          class m {
            constructor() {
              this.subscriptions = [];
            }
            add(t3) {
              return h(this.subscriptions, t3), () => d(this.subscriptions, t3);
            }
            notify(t3, e3, n3) {
              const s2 = this.subscriptions.length;
              if (s2)
                if (1 === s2)
                  this.subscriptions[0](t3, e3, n3);
                else
                  for (let i2 = 0; i2 < s2; i2++) {
                    const s3 = this.subscriptions[i2];
                    s3 && s3(t3, e3, n3);
                  }
            }
            getSize() {
              return this.subscriptions.length;
            }
            clear() {
              this.subscriptions.length = 0;
            }
          }
          function p(t3, e3) {
            return e3 ? t3 * (1e3 / e3) : 0;
          }
          class f {
            constructor() {
              this.order = [], this.scheduled = /* @__PURE__ */ new Set();
            }
            add(t3) {
              if (!this.scheduled.has(t3))
                return this.scheduled.add(t3), this.order.push(t3), true;
            }
            remove(t3) {
              const e3 = this.order.indexOf(t3);
              -1 !== e3 && (this.order.splice(e3, 1), this.scheduled.delete(t3));
            }
            clear() {
              this.order.length = 0, this.scheduled.clear();
            }
          }
          const g = ["prepare", "read", "update", "preRender", "render", "postRender"], { schedule: y, cancel: v, state: x, steps: P } = function(t3, e3) {
            let n3 = false, s2 = true;
            const i2 = { delta: 0, timestamp: 0, isProcessing: false }, o2 = g.reduce((t4, e4) => (t4[e4] = function(t5) {
              let e5 = new f(), n4 = new f(), s3 = 0, i3 = false, o3 = false;
              const r3 = /* @__PURE__ */ new WeakSet(), a3 = { schedule: (t6, o4 = false, a4 = false) => {
                const l2 = a4 && i3, u2 = l2 ? e5 : n4;
                return o4 && r3.add(t6), u2.add(t6) && l2 && i3 && (s3 = e5.order.length), t6;
              }, cancel: (t6) => {
                n4.remove(t6), r3.delete(t6);
              }, process: (l2) => {
                if (i3)
                  o3 = true;
                else {
                  if (i3 = true, [e5, n4] = [n4, e5], n4.clear(), s3 = e5.order.length, s3)
                    for (let n5 = 0; n5 < s3; n5++) {
                      const s4 = e5.order[n5];
                      s4(l2), r3.has(s4) && (a3.schedule(s4), t5());
                    }
                  i3 = false, o3 && (o3 = false, a3.process(l2));
                }
              } };
              return a3;
            }(() => n3 = true), t4), {}), r2 = (t4) => o2[t4].process(i2), a2 = () => {
              const e4 = performance.now();
              n3 = false, i2.delta = s2 ? 1e3 / 60 : Math.max(Math.min(e4 - i2.timestamp, 40), 1), i2.timestamp = e4, i2.isProcessing = true, g.forEach(r2), i2.isProcessing = false, n3 && (s2 = false, t3(a2));
            };
            return { schedule: g.reduce((e4, r3) => {
              const l2 = o2[r3];
              return e4[r3] = (e5, o3 = false, r4 = false) => (n3 || (n3 = true, s2 = true, i2.isProcessing || t3(a2)), l2.schedule(e5, o3, r4)), e4;
            }, {}), cancel: (t4) => g.forEach((e4) => o2[e4].cancel(t4)), state: i2, steps: o2 };
          }("undefined" != typeof requestAnimationFrame ? requestAnimationFrame : n2), b = { current: void 0 };
          class T {
            constructor(t3, e3 = {}) {
              var n3;
              this.version = "10.16.5", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = false, this.events = {}, this.updateAndNotify = (t4, e4 = true) => {
                this.prev = this.current, this.current = t4;
                const { delta: n4, timestamp: s2 } = x;
                this.lastUpdated !== s2 && (this.timeDelta = n4, this.lastUpdated = s2, y.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), e4 && this.events.renderRequest && this.events.renderRequest.notify(this.current);
              }, this.scheduleVelocityCheck = () => y.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: t4 }) => {
                t4 !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
              }, this.hasAnimated = false, this.prev = this.current = t3, this.canTrackVelocity = (n3 = this.current, !isNaN(parseFloat(n3))), this.owner = e3.owner;
            }
            onChange(t3) {
              return this.on("change", t3);
            }
            on(t3, e3) {
              this.events[t3] || (this.events[t3] = new m());
              const n3 = this.events[t3].add(e3);
              return "change" === t3 ? () => {
                n3(), y.read(() => {
                  this.events.change.getSize() || this.stop();
                });
              } : n3;
            }
            clearListeners() {
              for (const t3 in this.events)
                this.events[t3].clear();
            }
            attach(t3, e3) {
              this.passiveEffect = t3, this.stopPassiveEffect = e3;
            }
            set(t3, e3 = true) {
              e3 && this.passiveEffect ? this.passiveEffect(t3, this.updateAndNotify) : this.updateAndNotify(t3, e3);
            }
            setWithVelocity(t3, e3, n3) {
              this.set(e3), this.prev = t3, this.timeDelta = n3;
            }
            jump(t3) {
              this.updateAndNotify(t3), this.prev = t3, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
            }
            get() {
              return b.current && b.current.push(this), this.current;
            }
            getPrevious() {
              return this.prev;
            }
            getVelocity() {
              return this.canTrackVelocity ? p(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
            }
            start(t3) {
              return this.stop(), new Promise((e3) => {
                this.hasAnimated = true, this.animation = t3(e3), this.events.animationStart && this.events.animationStart.notify();
              }).then(() => {
                this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
              });
            }
            stop() {
              this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
            }
            isAnimating() {
              return !!this.animation;
            }
            clearAnimation() {
              delete this.animation;
            }
            destroy() {
              this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
            }
          }
          function S(t3, e3) {
            return new T(t3, e3);
          }
          const w = (t3) => (e3) => "string" == typeof e3 && e3.startsWith(t3), E = w("--"), A = w("var(--"), V = (t3) => Math.round(1e5 * t3) / 1e5, C = /(-)?([\d]*\.?[\d])+/g, M = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, D = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
          function k(t3) {
            return "string" == typeof t3;
          }
          const R = (t3, e3, n3) => Math.min(Math.max(n3, t3), e3), L = { test: (t3) => "number" == typeof t3, parse: parseFloat, transform: (t3) => t3 }, j = { ...L, transform: (t3) => R(0, 1, t3) }, B = { ...L, default: 1 }, F = (t3, e3) => (n3) => Boolean(k(n3) && D.test(n3) && n3.startsWith(t3) || e3 && Object.prototype.hasOwnProperty.call(n3, e3)), O = (t3, e3, n3) => (s2) => {
            if (!k(s2))
              return s2;
            const [i2, o2, r2, a2] = s2.match(C);
            return { [t3]: parseFloat(i2), [e3]: parseFloat(o2), [n3]: parseFloat(r2), alpha: void 0 !== a2 ? parseFloat(a2) : 1 };
          }, I = { ...L, transform: (t3) => Math.round(((t4) => R(0, 255, t4))(t3)) }, U = { test: F("rgb", "red"), parse: O("red", "green", "blue"), transform: ({ red: t3, green: e3, blue: n3, alpha: s2 = 1 }) => "rgba(" + I.transform(t3) + ", " + I.transform(e3) + ", " + I.transform(n3) + ", " + V(j.transform(s2)) + ")" }, N = { test: F("#"), parse: function(t3) {
            let e3 = "", n3 = "", s2 = "", i2 = "";
            return t3.length > 5 ? (e3 = t3.substring(1, 3), n3 = t3.substring(3, 5), s2 = t3.substring(5, 7), i2 = t3.substring(7, 9)) : (e3 = t3.substring(1, 2), n3 = t3.substring(2, 3), s2 = t3.substring(3, 4), i2 = t3.substring(4, 5), e3 += e3, n3 += n3, s2 += s2, i2 += i2), { red: parseInt(e3, 16), green: parseInt(n3, 16), blue: parseInt(s2, 16), alpha: i2 ? parseInt(i2, 16) / 255 : 1 };
          }, transform: U.transform }, $ = (t3) => ({ test: (e3) => k(e3) && e3.endsWith(t3) && 1 === e3.split(" ").length, parse: parseFloat, transform: (e3) => `${e3}${t3}` }), W = $("deg"), H = $("%"), z = $("px"), Y = $("vh"), X = $("vw"), G = { ...H, parse: (t3) => H.parse(t3) / 100, transform: (t3) => H.transform(100 * t3) }, q = { test: F("hsl", "hue"), parse: O("hue", "saturation", "lightness"), transform: ({ hue: t3, saturation: e3, lightness: n3, alpha: s2 = 1 }) => "hsla(" + Math.round(t3) + ", " + H.transform(V(e3)) + ", " + H.transform(V(n3)) + ", " + V(j.transform(s2)) + ")" }, Z = { test: (t3) => U.test(t3) || N.test(t3) || q.test(t3), parse: (t3) => U.test(t3) ? U.parse(t3) : q.test(t3) ? q.parse(t3) : N.parse(t3), transform: (t3) => k(t3) ? t3 : t3.hasOwnProperty("red") ? U.transform(t3) : q.transform(t3) }, K = { regex: /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g, countKey: "Vars", token: "${v}", parse: n2 }, _ = { regex: M, countKey: "Colors", token: "${c}", parse: Z.parse }, J = { regex: C, countKey: "Numbers", token: "${n}", parse: L.parse };
          function Q(t3, { regex: e3, countKey: n3, token: s2, parse: i2 }) {
            const o2 = t3.tokenised.match(e3);
            o2 && (t3["num" + n3] = o2.length, t3.tokenised = t3.tokenised.replace(e3, s2), t3.values.push(...o2.map(i2)));
          }
          function tt(t3) {
            const e3 = t3.toString(), n3 = { value: e3, tokenised: e3, values: [], numVars: 0, numColors: 0, numNumbers: 0 };
            return n3.value.includes("var(--") && Q(n3, K), Q(n3, _), Q(n3, J), n3;
          }
          function et(t3) {
            return tt(t3).values;
          }
          function nt(t3) {
            const { values: e3, numColors: n3, numVars: s2, tokenised: i2 } = tt(t3), o2 = e3.length;
            return (t4) => {
              let e4 = i2;
              for (let i3 = 0; i3 < o2; i3++)
                e4 = i3 < s2 ? e4.replace(K.token, t4[i3]) : i3 < s2 + n3 ? e4.replace(_.token, Z.transform(t4[i3])) : e4.replace(J.token, V(t4[i3]));
              return e4;
            };
          }
          const st = (t3) => "number" == typeof t3 ? 0 : t3, it = { test: function(t3) {
            var e3, n3;
            return isNaN(t3) && k(t3) && ((null === (e3 = t3.match(C)) || void 0 === e3 ? void 0 : e3.length) || 0) + ((null === (n3 = t3.match(M)) || void 0 === n3 ? void 0 : n3.length) || 0) > 0;
          }, parse: et, createTransformer: nt, getAnimatableNone: function(t3) {
            const e3 = et(t3);
            return nt(t3)(e3.map(st));
          } }, ot = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
          function rt(t3) {
            const [e3, n3] = t3.slice(0, -1).split("(");
            if ("drop-shadow" === e3)
              return t3;
            const [s2] = n3.match(C) || [];
            if (!s2)
              return t3;
            const i2 = n3.replace(s2, "");
            let o2 = ot.has(e3) ? 1 : 0;
            return s2 !== n3 && (o2 *= 100), e3 + "(" + o2 + i2 + ")";
          }
          const at = /([a-z-]*)\(.*?\)/g, lt = { ...it, getAnimatableNone: (t3) => {
            const e3 = t3.match(at);
            return e3 ? e3.map(rt).join(" ") : t3;
          } }, ut = { ...L, transform: Math.round }, ct = { borderWidth: z, borderTopWidth: z, borderRightWidth: z, borderBottomWidth: z, borderLeftWidth: z, borderRadius: z, radius: z, borderTopLeftRadius: z, borderTopRightRadius: z, borderBottomRightRadius: z, borderBottomLeftRadius: z, width: z, maxWidth: z, height: z, maxHeight: z, size: z, top: z, right: z, bottom: z, left: z, padding: z, paddingTop: z, paddingRight: z, paddingBottom: z, paddingLeft: z, margin: z, marginTop: z, marginRight: z, marginBottom: z, marginLeft: z, rotate: W, rotateX: W, rotateY: W, rotateZ: W, scale: B, scaleX: B, scaleY: B, scaleZ: B, skew: W, skewX: W, skewY: W, distance: z, translateX: z, translateY: z, translateZ: z, x: z, y: z, z, perspective: z, transformPerspective: z, opacity: j, originX: G, originY: G, originZ: z, zIndex: ut, fillOpacity: j, strokeOpacity: j, numOctaves: ut }, ht = { ...ct, color: Z, backgroundColor: Z, outlineColor: Z, fill: Z, stroke: Z, borderColor: Z, borderTopColor: Z, borderRightColor: Z, borderBottomColor: Z, borderLeftColor: Z, filter: lt, WebkitFilter: lt }, dt = (t3) => ht[t3];
          function mt(t3, e3) {
            let n3 = dt(t3);
            return n3 !== lt && (n3 = it), n3.getAnimatableNone ? n3.getAnimatableNone(e3) : void 0;
          }
          const pt = (t3) => (e3) => e3.test(t3), ft = [L, z, H, W, X, Y, { test: (t3) => "auto" === t3, parse: (t3) => t3 }], gt = (t3) => ft.find(pt(t3)), yt = [...ft, Z, it];
          function vt(t3, e3, n3, s2 = {}, i2 = {}) {
            return "function" == typeof e3 && (e3 = e3(void 0 !== n3 ? n3 : t3.custom, s2, i2)), "string" == typeof e3 && (e3 = t3.variants && t3.variants[e3]), "function" == typeof e3 && (e3 = e3(void 0 !== n3 ? n3 : t3.custom, s2, i2)), e3;
          }
          function xt(t3, e3, n3) {
            const s2 = t3.getProps();
            return vt(s2, e3, void 0 !== n3 ? n3 : s2.custom, function(t4) {
              const e4 = {};
              return t4.values.forEach((t5, n4) => e4[n4] = t5.get()), e4;
            }(t3), function(t4) {
              const e4 = {};
              return t4.values.forEach((t5, n4) => e4[n4] = t5.getVelocity()), e4;
            }(t3));
          }
          function Pt(t3, e3, n3) {
            t3.hasValue(e3) ? t3.getValue(e3).set(n3) : t3.addValue(e3, S(n3));
          }
          function bt(t3, e3) {
            const n3 = xt(t3, e3);
            let { transitionEnd: s2 = {}, transition: i2 = {}, ...o2 } = n3 ? t3.makeTargetAnimatable(n3, false) : {};
            o2 = { ...o2, ...s2 };
            for (const e4 in o2)
              Pt(t3, e4, (r2 = o2[e4], c(r2) ? r2[r2.length - 1] || 0 : r2));
            var r2;
          }
          function Tt(t3, e3) {
            [...e3].reverse().forEach((n3) => {
              const s2 = t3.getVariant(n3);
              s2 && bt(t3, s2), t3.variantChildren && t3.variantChildren.forEach((t4) => {
                Tt(t4, e3);
              });
            });
          }
          function St(t3, e3) {
            if (e3)
              return (e3[t3] || e3.default || e3).from;
          }
          const wt = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Et = new Set(wt), At = (t3) => t3.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), Vt = "data-" + At("framerAppearId"), Ct = (t3) => 1e3 * t3, Mt = (t3) => t3 / 1e3, Dt = (t3) => Array.isArray(t3) && "number" == typeof t3[0];
          function kt(t3) {
            return Boolean(!t3 || "string" == typeof t3 && Lt[t3] || Dt(t3) || Array.isArray(t3) && t3.every(kt));
          }
          const Rt = ([t3, e3, n3, s2]) => `cubic-bezier(${t3}, ${e3}, ${n3}, ${s2})`, Lt = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Rt([0, 0.65, 0.55, 1]), circOut: Rt([0.55, 0, 1, 0.45]), backIn: Rt([0.31, 0.01, 0.66, -0.59]), backOut: Rt([0.33, 1.53, 0.69, 0.99]) };
          function jt(t3) {
            if (t3)
              return Dt(t3) ? Rt(t3) : Array.isArray(t3) ? t3.map(jt) : Lt[t3];
          }
          const Bt = (t3, e3, n3) => (((1 - 3 * n3 + 3 * e3) * t3 + (3 * n3 - 6 * e3)) * t3 + 3 * e3) * t3;
          function Ft(t3, e3, s2, i2) {
            if (t3 === e3 && s2 === i2)
              return n2;
            return (n3) => 0 === n3 || 1 === n3 ? n3 : Bt(function(t4, e4, n4, s3, i3) {
              let o2, r2, a2 = 0;
              do {
                r2 = e4 + (n4 - e4) / 2, o2 = Bt(r2, s3, i3) - t4, o2 > 0 ? n4 = r2 : e4 = r2;
              } while (Math.abs(o2) > 1e-7 && ++a2 < 12);
              return r2;
            }(n3, 0, 1, t3, s2), e3, i2);
          }
          const Ot = Ft(0.42, 0, 1, 1), It = Ft(0, 0, 0.58, 1), Ut = Ft(0.42, 0, 0.58, 1), Nt = (t3) => (e3) => e3 <= 0.5 ? t3(2 * e3) / 2 : (2 - t3(2 * (1 - e3))) / 2, $t = (t3) => (e3) => 1 - t3(1 - e3), Wt = (t3) => 1 - Math.sin(Math.acos(t3)), Ht = $t(Wt), zt = Nt(Ht), Yt = Ft(0.33, 1.53, 0.69, 0.99), Xt = $t(Yt), Gt = Nt(Xt), qt = { linear: n2, easeIn: Ot, easeInOut: Ut, easeOut: It, circIn: Wt, circInOut: zt, circOut: Ht, backIn: Xt, backInOut: Gt, backOut: Yt, anticipate: (t3) => (t3 *= 2) < 1 ? 0.5 * Xt(t3) : 0.5 * (2 - Math.pow(2, -10 * (t3 - 1))) }, Zt = (t3) => {
            if (Array.isArray(t3)) {
              r(4 === t3.length, "Cubic bezier arrays must contain four numerical values.");
              const [e3, n3, s2, i2] = t3;
              return Ft(e3, n3, s2, i2);
            }
            return "string" == typeof t3 ? (r(void 0 !== qt[t3], `Invalid easing type '${t3}'`), qt[t3]) : t3;
          }, Kt = (t3, e3, n3) => -n3 * t3 + n3 * e3 + t3;
          function _t(t3, e3, n3) {
            return n3 < 0 && (n3 += 1), n3 > 1 && (n3 -= 1), n3 < 1 / 6 ? t3 + 6 * (e3 - t3) * n3 : n3 < 0.5 ? e3 : n3 < 2 / 3 ? t3 + (e3 - t3) * (2 / 3 - n3) * 6 : t3;
          }
          const Jt = (t3, e3, n3) => {
            const s2 = t3 * t3;
            return Math.sqrt(Math.max(0, n3 * (e3 * e3 - s2) + s2));
          }, Qt = [N, U, q];
          function te(t3) {
            const e3 = (n3 = t3, Qt.find((t4) => t4.test(n3)));
            var n3;
            r(Boolean(e3), `'${t3}' is not an animatable color. Use the equivalent color code instead.`);
            let s2 = e3.parse(t3);
            return e3 === q && (s2 = function({ hue: t4, saturation: e4, lightness: n4, alpha: s3 }) {
              t4 /= 360, n4 /= 100;
              let i2 = 0, o2 = 0, r2 = 0;
              if (e4 /= 100) {
                const s4 = n4 < 0.5 ? n4 * (1 + e4) : n4 + e4 - n4 * e4, a2 = 2 * n4 - s4;
                i2 = _t(a2, s4, t4 + 1 / 3), o2 = _t(a2, s4, t4), r2 = _t(a2, s4, t4 - 1 / 3);
              } else
                i2 = o2 = r2 = n4;
              return { red: Math.round(255 * i2), green: Math.round(255 * o2), blue: Math.round(255 * r2), alpha: s3 };
            }(s2)), s2;
          }
          const ee = (t3, e3) => {
            const n3 = te(t3), s2 = te(e3), i2 = { ...n3 };
            return (t4) => (i2.red = Jt(n3.red, s2.red, t4), i2.green = Jt(n3.green, s2.green, t4), i2.blue = Jt(n3.blue, s2.blue, t4), i2.alpha = Kt(n3.alpha, s2.alpha, t4), U.transform(i2));
          }, ne = (t3, e3) => (n3) => e3(t3(n3)), se = (...t3) => t3.reduce(ne), ie = (t3, e3) => (n3) => `${n3 > 0 ? e3 : t3}`;
          function oe(t3, e3) {
            return "number" == typeof t3 ? (n3) => Kt(t3, e3, n3) : Z.test(t3) ? ee(t3, e3) : t3.startsWith("var(") ? ie(t3, e3) : le(t3, e3);
          }
          const re = (t3, e3) => {
            const n3 = [...t3], s2 = n3.length, i2 = t3.map((t4, n4) => oe(t4, e3[n4]));
            return (t4) => {
              for (let e4 = 0; e4 < s2; e4++)
                n3[e4] = i2[e4](t4);
              return n3;
            };
          }, ae = (t3, e3) => {
            const n3 = { ...t3, ...e3 }, s2 = {};
            for (const i2 in n3)
              void 0 !== t3[i2] && void 0 !== e3[i2] && (s2[i2] = oe(t3[i2], e3[i2]));
            return (t4) => {
              for (const e4 in s2)
                n3[e4] = s2[e4](t4);
              return n3;
            };
          }, le = (t3, e3) => {
            const n3 = it.createTransformer(e3), s2 = tt(t3), i2 = tt(e3);
            return s2.numVars === i2.numVars && s2.numColors === i2.numColors && s2.numNumbers >= i2.numNumbers ? se(re(s2.values, i2.values), n3) : (o(true, `Complex values '${t3}' and '${e3}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), ie(t3, e3));
          }, ue = (t3, e3, n3) => {
            const s2 = e3 - t3;
            return 0 === s2 ? 1 : (n3 - t3) / s2;
          }, ce = (t3, e3) => (n3) => Kt(t3, e3, n3);
          function he(t3, e3, { clamp: s2 = true, ease: i2, mixer: o2 } = {}) {
            const a2 = t3.length;
            if (r(a2 === e3.length, "Both input and output ranges must be the same length"), 1 === a2)
              return () => e3[0];
            t3[0] > t3[a2 - 1] && (t3 = [...t3].reverse(), e3 = [...e3].reverse());
            const l2 = function(t4, e4, s3) {
              const i3 = [], o3 = s3 || ("number" == typeof (r2 = t4[0]) ? ce : "string" == typeof r2 ? Z.test(r2) ? ee : le : Array.isArray(r2) ? re : "object" == typeof r2 ? ae : ce);
              var r2;
              const a3 = t4.length - 1;
              for (let s4 = 0; s4 < a3; s4++) {
                let r3 = o3(t4[s4], t4[s4 + 1]);
                if (e4) {
                  const t5 = Array.isArray(e4) ? e4[s4] || n2 : e4;
                  r3 = se(t5, r3);
                }
                i3.push(r3);
              }
              return i3;
            }(e3, i2, o2), u2 = l2.length, c2 = (e4) => {
              let n3 = 0;
              if (u2 > 1)
                for (; n3 < t3.length - 2 && !(e4 < t3[n3 + 1]); n3++)
                  ;
              const s3 = ue(t3[n3], t3[n3 + 1], e4);
              return l2[n3](s3);
            };
            return s2 ? (e4) => c2(R(t3[0], t3[a2 - 1], e4)) : c2;
          }
          function de({ duration: t3 = 300, keyframes: e3, times: n3, ease: s2 = "easeInOut" }) {
            const i2 = ((t4) => Array.isArray(t4) && "number" != typeof t4[0])(s2) ? s2.map(Zt) : Zt(s2), o2 = { done: false, value: e3[0] }, r2 = he(function(t4, e4) {
              return t4.map((t5) => t5 * e4);
            }(n3 && n3.length === e3.length ? n3 : function(t4) {
              const e4 = [0];
              return function(t5, e5) {
                const n4 = t5[t5.length - 1];
                for (let s3 = 1; s3 <= e5; s3++) {
                  const i3 = ue(0, e5, s3);
                  t5.push(Kt(n4, 1, i3));
                }
              }(e4, t4.length - 1), e4;
            }(e3), t3), e3, { ease: Array.isArray(i2) ? i2 : (a2 = e3, l2 = i2, a2.map(() => l2 || Ut).splice(0, a2.length - 1)) });
            var a2, l2;
            return { calculatedDuration: t3, next: (e4) => (o2.value = r2(e4), o2.done = e4 >= t3, o2) };
          }
          function me(t3, e3, n3) {
            const s2 = Math.max(e3 - 5, 0);
            return p(n3 - t3(s2), e3 - s2);
          }
          function pe(t3, e3) {
            return t3 * Math.sqrt(1 - e3 * e3);
          }
          const fe = ["duration", "bounce"], ge = ["stiffness", "damping", "mass"];
          function ye(t3, e3) {
            return e3.some((e4) => void 0 !== t3[e4]);
          }
          function ve({ keyframes: t3, restDelta: e3, restSpeed: n3, ...s2 }) {
            const i2 = t3[0], r2 = t3[t3.length - 1], a2 = { done: false, value: i2 }, { stiffness: l2, damping: u2, mass: c2, velocity: h2, duration: d2, isResolvedFromDuration: m2 } = function(t4) {
              let e4 = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false, ...t4 };
              if (!ye(t4, ge) && ye(t4, fe)) {
                const n4 = function({ duration: t5 = 800, bounce: e5 = 0.25, velocity: n5 = 0, mass: s3 = 1 }) {
                  let i3, r3;
                  o(t5 <= Ct(10), "Spring duration must be 10 seconds or less");
                  let a3 = 1 - e5;
                  a3 = R(0.05, 1, a3), t5 = R(0.01, 10, Mt(t5)), a3 < 1 ? (i3 = (e6) => {
                    const s4 = e6 * a3, i4 = s4 * t5;
                    return 1e-3 - (s4 - n5) / pe(e6, a3) * Math.exp(-i4);
                  }, r3 = (e6) => {
                    const s4 = e6 * a3 * t5, o2 = s4 * n5 + n5, r4 = Math.pow(a3, 2) * Math.pow(e6, 2) * t5, l4 = Math.exp(-s4), u3 = pe(Math.pow(e6, 2), a3);
                    return (1e-3 - i3(e6) > 0 ? -1 : 1) * ((o2 - r4) * l4) / u3;
                  }) : (i3 = (e6) => Math.exp(-e6 * t5) * ((e6 - n5) * t5 + 1) - 1e-3, r3 = (e6) => Math.exp(-e6 * t5) * (t5 * t5 * (n5 - e6)));
                  const l3 = function(t6, e6, n6) {
                    let s4 = n6;
                    for (let n7 = 1; n7 < 12; n7++)
                      s4 -= t6(s4) / e6(s4);
                    return s4;
                  }(i3, r3, 5 / t5);
                  if (t5 = Ct(t5), isNaN(l3))
                    return { stiffness: 100, damping: 10, duration: t5 };
                  {
                    const e6 = Math.pow(l3, 2) * s3;
                    return { stiffness: e6, damping: 2 * a3 * Math.sqrt(s3 * e6), duration: t5 };
                  }
                }(t4);
                e4 = { ...e4, ...n4, velocity: 0, mass: 1 }, e4.isResolvedFromDuration = true;
              }
              return e4;
            }(s2), p2 = h2 ? -Mt(h2) : 0, f2 = u2 / (2 * Math.sqrt(l2 * c2)), g2 = r2 - i2, y2 = Mt(Math.sqrt(l2 / c2)), v2 = Math.abs(g2) < 5;
            let x2;
            if (n3 || (n3 = v2 ? 0.01 : 2), e3 || (e3 = v2 ? 5e-3 : 0.5), f2 < 1) {
              const t4 = pe(y2, f2);
              x2 = (e4) => {
                const n4 = Math.exp(-f2 * y2 * e4);
                return r2 - n4 * ((p2 + f2 * y2 * g2) / t4 * Math.sin(t4 * e4) + g2 * Math.cos(t4 * e4));
              };
            } else if (1 === f2)
              x2 = (t4) => r2 - Math.exp(-y2 * t4) * (g2 + (p2 + y2 * g2) * t4);
            else {
              const t4 = y2 * Math.sqrt(f2 * f2 - 1);
              x2 = (e4) => {
                const n4 = Math.exp(-f2 * y2 * e4), s3 = Math.min(t4 * e4, 300);
                return r2 - n4 * ((p2 + f2 * y2 * g2) * Math.sinh(s3) + t4 * g2 * Math.cosh(s3)) / t4;
              };
            }
            return { calculatedDuration: m2 && d2 || null, next: (t4) => {
              const s3 = x2(t4);
              if (m2)
                a2.done = t4 >= d2;
              else {
                let i3 = p2;
                0 !== t4 && (i3 = f2 < 1 ? me(x2, t4, s3) : 0);
                const o2 = Math.abs(i3) <= n3, l3 = Math.abs(r2 - s3) <= e3;
                a2.done = o2 && l3;
              }
              return a2.value = a2.done ? r2 : s3, a2;
            } };
          }
          function xe({ keyframes: t3, velocity: e3 = 0, power: n3 = 0.8, timeConstant: s2 = 325, bounceDamping: i2 = 10, bounceStiffness: o2 = 500, modifyTarget: r2, min: a2, max: l2, restDelta: u2 = 0.5, restSpeed: c2 }) {
            const h2 = t3[0], d2 = { done: false, value: h2 }, m2 = (t4) => void 0 === a2 ? l2 : void 0 === l2 || Math.abs(a2 - t4) < Math.abs(l2 - t4) ? a2 : l2;
            let p2 = n3 * e3;
            const f2 = h2 + p2, g2 = void 0 === r2 ? f2 : r2(f2);
            g2 !== f2 && (p2 = g2 - h2);
            const y2 = (t4) => -p2 * Math.exp(-t4 / s2), v2 = (t4) => g2 + y2(t4), x2 = (t4) => {
              const e4 = y2(t4), n4 = v2(t4);
              d2.done = Math.abs(e4) <= u2, d2.value = d2.done ? g2 : n4;
            };
            let P2, b2;
            const T2 = (t4) => {
              var e4;
              e4 = d2.value, (void 0 !== a2 && e4 < a2 || void 0 !== l2 && e4 > l2) && (P2 = t4, b2 = ve({ keyframes: [d2.value, m2(d2.value)], velocity: me(v2, t4, d2.value), damping: i2, stiffness: o2, restDelta: u2, restSpeed: c2 }));
            };
            return T2(0), { calculatedDuration: null, next: (t4) => {
              let e4 = false;
              return b2 || void 0 !== P2 || (e4 = true, x2(t4), T2(t4)), void 0 !== P2 && t4 > P2 ? b2.next(t4 - P2) : (!e4 && x2(t4), d2);
            } };
          }
          const Pe = (t3) => {
            const e3 = ({ timestamp: e4 }) => t3(e4);
            return { start: () => y.update(e3, true), stop: () => v(e3), now: () => x.isProcessing ? x.timestamp : performance.now() };
          };
          function be(t3) {
            let e3 = 0, n3 = t3.next(e3);
            for (; !n3.done && e3 < 2e4; )
              e3 += 50, n3 = t3.next(e3);
            return e3 >= 2e4 ? 1 / 0 : e3;
          }
          const Te = { decay: xe, inertia: xe, tween: de, keyframes: de, spring: ve };
          function Se({ autoplay: t3 = true, delay: e3 = 0, driver: n3 = Pe, keyframes: s2, type: i2 = "keyframes", repeat: o2 = 0, repeatDelay: r2 = 0, repeatType: a2 = "loop", onPlay: l2, onStop: u2, onComplete: c2, onUpdate: h2, ...d2 }) {
            let m2, p2, f2 = 1, g2 = false;
            const y2 = () => {
              p2 = new Promise((t4) => {
                m2 = t4;
              });
            };
            let v2;
            y2();
            const x2 = Te[i2] || de;
            let P2;
            x2 !== de && "number" != typeof s2[0] && (P2 = he([0, 100], s2, { clamp: false }), s2 = [0, 100]);
            const b2 = x2({ ...d2, keyframes: s2 });
            let T2;
            "mirror" === a2 && (T2 = x2({ ...d2, keyframes: [...s2].reverse(), velocity: -(d2.velocity || 0) }));
            let S2 = "idle", w2 = null, E2 = null, A2 = null;
            null === b2.calculatedDuration && o2 && (b2.calculatedDuration = be(b2));
            const { calculatedDuration: V2 } = b2;
            let C2 = 1 / 0, M2 = 1 / 0;
            null !== V2 && (C2 = V2 + r2, M2 = C2 * (o2 + 1) - r2);
            let D2 = 0;
            const k2 = (t4) => {
              if (null === E2)
                return;
              f2 > 0 && (E2 = Math.min(E2, t4)), f2 < 0 && (E2 = Math.min(t4 - M2 / f2, E2)), D2 = null !== w2 ? w2 : Math.round(t4 - E2) * f2;
              const n4 = D2 - e3 * (f2 >= 0 ? 1 : -1), i3 = f2 >= 0 ? n4 < 0 : n4 > M2;
              D2 = Math.max(n4, 0), "finished" === S2 && null === w2 && (D2 = M2);
              let l3 = D2, u3 = b2;
              if (o2) {
                const t5 = D2 / C2;
                let e4 = Math.floor(t5), n5 = t5 % 1;
                !n5 && t5 >= 1 && (n5 = 1), 1 === n5 && e4--, e4 = Math.min(e4, o2 + 1);
                const s3 = Boolean(e4 % 2);
                s3 && ("reverse" === a2 ? (n5 = 1 - n5, r2 && (n5 -= r2 / C2)) : "mirror" === a2 && (u3 = T2));
                let i4 = R(0, 1, n5);
                D2 > M2 && (i4 = "reverse" === a2 && s3 ? 1 : 0), l3 = i4 * C2;
              }
              const c3 = i3 ? { done: false, value: s2[0] } : u3.next(l3);
              P2 && (c3.value = P2(c3.value));
              let { done: d3 } = c3;
              i3 || null === V2 || (d3 = f2 >= 0 ? D2 >= M2 : D2 <= 0);
              const m3 = null === w2 && ("finished" === S2 || "running" === S2 && d3);
              return h2 && h2(c3.value), m3 && B2(), c3;
            }, L2 = () => {
              v2 && v2.stop(), v2 = void 0;
            }, j2 = () => {
              S2 = "idle", L2(), m2(), y2(), E2 = A2 = null;
            }, B2 = () => {
              S2 = "finished", c2 && c2(), L2(), m2();
            }, F2 = () => {
              if (g2)
                return;
              v2 || (v2 = n3(k2));
              const t4 = v2.now();
              l2 && l2(), null !== w2 ? E2 = t4 - w2 : E2 && "finished" !== S2 || (E2 = t4), "finished" === S2 && y2(), A2 = E2, w2 = null, S2 = "running", v2.start();
            };
            t3 && F2();
            const O2 = { then: (t4, e4) => p2.then(t4, e4), get time() {
              return Mt(D2);
            }, set time(t4) {
              t4 = Ct(t4), D2 = t4, null === w2 && v2 && 0 !== f2 ? E2 = v2.now() - t4 / f2 : w2 = t4;
            }, get duration() {
              const t4 = null === b2.calculatedDuration ? be(b2) : b2.calculatedDuration;
              return Mt(t4);
            }, get speed() {
              return f2;
            }, set speed(t4) {
              t4 !== f2 && v2 && (f2 = t4, O2.time = Mt(D2));
            }, get state() {
              return S2;
            }, play: F2, pause: () => {
              S2 = "paused", w2 = D2;
            }, stop: () => {
              g2 = true, "idle" !== S2 && (S2 = "idle", u2 && u2(), j2());
            }, cancel: () => {
              null !== A2 && k2(A2), j2();
            }, complete: () => {
              S2 = "finished";
            }, sample: (t4) => (E2 = 0, k2(t4)) };
            return O2;
          }
          const we = /* @__PURE__ */ function(t3) {
            let e3;
            return () => (void 0 === e3 && (e3 = Object.hasOwnProperty.call(Element.prototype, "animate")), e3);
          }(), Ee = /* @__PURE__ */ new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"]);
          const Ae = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, Ve = { type: "keyframes", duration: 0.8 }, Ce = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 }, Me = (t3, { keyframes: e3 }) => e3.length > 2 ? Ve : Et.has(t3) ? t3.startsWith("scale") ? { type: "spring", stiffness: 550, damping: 0 === e3[1] ? 2 * Math.sqrt(550) : 30, restSpeed: 10 } : Ae : Ce, De = (t3, e3) => !("zIndex" === t3 || "number" != typeof e3 && !Array.isArray(e3) && ("string" != typeof e3 || !it.test(e3) && "0" !== e3 || e3.startsWith("url(")));
          function ke(t3) {
            return "number" == typeof t3 ? 0 === t3 : null !== t3 ? "none" === t3 || "0" === t3 || u(t3) : void 0;
          }
          function Re(t3, e3) {
            return t3[e3] || t3.default || t3;
          }
          const Le = (t3, e3, s2, i2 = {}) => (r2) => {
            const a2 = Re(i2, t3) || {}, l2 = a2.delay || i2.delay || 0;
            let { elapsed: u2 = 0 } = i2;
            u2 -= Ct(l2);
            const c2 = function(t4, e4, n3, s3) {
              const i3 = De(e4, n3);
              let o2;
              o2 = Array.isArray(n3) ? [...n3] : [null, n3];
              const r3 = void 0 !== s3.from ? s3.from : t4.get();
              let a3;
              const l3 = [];
              for (let t5 = 0; t5 < o2.length; t5++)
                null === o2[t5] && (o2[t5] = 0 === t5 ? r3 : o2[t5 - 1]), ke(o2[t5]) && l3.push(t5), "string" == typeof o2[t5] && "none" !== o2[t5] && "0" !== o2[t5] && (a3 = o2[t5]);
              if (i3 && l3.length && a3)
                for (let t5 = 0; t5 < l3.length; t5++)
                  o2[l3[t5]] = mt(e4, a3);
              return o2;
            }(e3, t3, s2, a2), h2 = c2[0], d2 = c2[c2.length - 1], m2 = De(t3, h2), p2 = De(t3, d2);
            o(m2 === p2, `You are trying to animate ${t3} from "${h2}" to "${d2}". ${h2} is not an animatable value - to enable this animation set ${h2} to a value animatable to ${d2} via the \`style\` property.`);
            let f2 = { keyframes: c2, velocity: e3.getVelocity(), ease: "easeOut", ...a2, delay: -u2, onUpdate: (t4) => {
              e3.set(t4), a2.onUpdate && a2.onUpdate(t4);
            }, onComplete: () => {
              r2(), a2.onComplete && a2.onComplete();
            } };
            if (function({ when: t4, delay: e4, delayChildren: n3, staggerChildren: s3, staggerDirection: i3, repeat: o2, repeatType: r3, repeatDelay: a3, from: l3, elapsed: u3, ...c3 }) {
              return !!Object.keys(c3).length;
            }(a2) || (f2 = { ...f2, ...Me(t3, f2) }), f2.duration && (f2.duration = Ct(f2.duration)), f2.repeatDelay && (f2.repeatDelay = Ct(f2.repeatDelay)), !m2 || !p2 || false === a2.type)
              return function({ keyframes: t4, delay: e4, onUpdate: s3, onComplete: i3 }) {
                const o2 = () => (s3 && s3(t4[t4.length - 1]), i3 && i3(), { time: 0, speed: 1, duration: 0, play: n2, pause: n2, stop: n2, then: (t5) => (t5(), Promise.resolve()), cancel: n2, complete: n2 });
                return e4 ? Se({ keyframes: [0, 1], duration: 0, delay: e4, onComplete: o2 }) : o2();
              }(f2);
            if (e3.owner && e3.owner.current instanceof HTMLElement && !e3.owner.getProps().onUpdate) {
              const s3 = function(t4, e4, { onUpdate: s4, onComplete: i3, ...o2 }) {
                if (!we() || !Ee.has(e4) || o2.repeatDelay || "mirror" === o2.repeatType || 0 === o2.damping || "inertia" === o2.type)
                  return false;
                let r3, a3, l3 = false;
                const u3 = () => {
                  a3 = new Promise((t5) => {
                    r3 = t5;
                  });
                };
                u3();
                let { keyframes: c3, duration: h3 = 300, ease: d3, times: m3 } = o2;
                if (((t5, e5) => "spring" === e5.type || "backgroundColor" === t5 || !kt(e5.ease))(e4, o2)) {
                  const t5 = Se({ ...o2, repeat: 0, delay: 0 });
                  let e5 = { done: false, value: c3[0] };
                  const n3 = [];
                  let s5 = 0;
                  for (; !e5.done && s5 < 2e4; )
                    e5 = t5.sample(s5), n3.push(e5.value), s5 += 10;
                  m3 = void 0, c3 = n3, h3 = s5 - 10, d3 = "linear";
                }
                const p3 = function(t5, e5, n3, { delay: s5 = 0, duration: i4, repeat: o3 = 0, repeatType: r4 = "loop", ease: a4, times: l4 } = {}) {
                  const u4 = { [e5]: n3 };
                  l4 && (u4.offset = l4);
                  const c4 = jt(a4);
                  return Array.isArray(c4) && (u4.easing = c4), t5.animate(u4, { delay: s5, duration: i4, easing: Array.isArray(c4) ? "linear" : c4, fill: "both", iterations: o3 + 1, direction: "reverse" === r4 ? "alternate" : "normal" });
                }(t4.owner.current, e4, c3, { ...o2, duration: h3, ease: d3, times: m3 });
                o2.syncStart && (p3.startTime = x.isProcessing ? x.timestamp : document.timeline ? document.timeline.currentTime : performance.now());
                const f3 = () => p3.cancel(), g2 = () => {
                  y.update(f3), r3(), u3();
                };
                return p3.onfinish = () => {
                  t4.set(function(t5, { repeat: e5, repeatType: n3 = "loop" }) {
                    return t5[e5 && "loop" !== n3 && e5 % 2 == 1 ? 0 : t5.length - 1];
                  }(c3, o2)), i3 && i3(), g2();
                }, { then: (t5, e5) => a3.then(t5, e5), attachTimeline: (t5) => (p3.timeline = t5, p3.onfinish = null, n2), get time() {
                  return Mt(p3.currentTime || 0);
                }, set time(t5) {
                  p3.currentTime = Ct(t5);
                }, get speed() {
                  return p3.playbackRate;
                }, set speed(t5) {
                  p3.playbackRate = t5;
                }, get duration() {
                  return Mt(h3);
                }, play: () => {
                  l3 || (p3.play(), v(f3));
                }, pause: () => p3.pause(), stop: () => {
                  if (l3 = true, "idle" === p3.playState)
                    return;
                  const { currentTime: e5 } = p3;
                  if (e5) {
                    const n3 = Se({ ...o2, autoplay: false });
                    t4.setWithVelocity(n3.sample(e5 - 10).value, n3.sample(e5).value, 10);
                  }
                  g2();
                }, complete: () => p3.finish(), cancel: g2 };
              }(e3, t3, f2);
              if (s3)
                return s3;
            }
            return Se(f2);
          }, je = (t3) => Boolean(t3 && t3.getVelocity);
          function Be(t3) {
            return Boolean(je(t3) && t3.add);
          }
          function Fe({ protectedKeys: t3, needsAnimating: e3 }, n3) {
            const s2 = t3.hasOwnProperty(n3) && true !== e3[n3];
            return e3[n3] = false, s2;
          }
          function Oe(t3, e3, { delay: n3 = 0, transitionOverride: s2, type: i2 } = {}) {
            let { transition: o2 = t3.getDefaultTransition(), transitionEnd: r2, ...a2 } = t3.makeTargetAnimatable(e3);
            const l2 = t3.getValue("willChange");
            s2 && (o2 = s2);
            const u2 = [], c2 = i2 && t3.animationState && t3.animationState.getState()[i2];
            for (const e4 in a2) {
              const s3 = t3.getValue(e4), i3 = a2[e4];
              if (!s3 || void 0 === i3 || c2 && Fe(c2, e4))
                continue;
              const r3 = { delay: n3, elapsed: 0, ...o2 };
              if (window.HandoffAppearAnimations && !s3.hasAnimated) {
                const n4 = t3.getProps()[Vt];
                n4 && (r3.elapsed = window.HandoffAppearAnimations(n4, e4, s3, y), r3.syncStart = true);
              }
              s3.start(Le(e4, s3, i3, t3.shouldReduceMotion && Et.has(e4) ? { type: false } : r3));
              const h2 = s3.animation;
              Be(l2) && (l2.add(e4), h2.then(() => l2.remove(e4))), u2.push(h2);
            }
            return r2 && Promise.all(u2).then(() => {
              r2 && bt(t3, r2);
            }), u2;
          }
          function Ie(t3, e3, n3 = {}) {
            const s2 = xt(t3, e3, n3.custom);
            let { transition: i2 = t3.getDefaultTransition() || {} } = s2 || {};
            n3.transitionOverride && (i2 = n3.transitionOverride);
            const o2 = s2 ? () => Promise.all(Oe(t3, s2, n3)) : () => Promise.resolve(), r2 = t3.variantChildren && t3.variantChildren.size ? (s3 = 0) => {
              const { delayChildren: o3 = 0, staggerChildren: r3, staggerDirection: a3 } = i2;
              return function(t4, e4, n4 = 0, s4 = 0, i3 = 1, o4) {
                const r4 = [], a4 = (t4.variantChildren.size - 1) * s4, l2 = 1 === i3 ? (t5 = 0) => t5 * s4 : (t5 = 0) => a4 - t5 * s4;
                return Array.from(t4.variantChildren).sort(Ue).forEach((t5, s5) => {
                  t5.notify("AnimationStart", e4), r4.push(Ie(t5, e4, { ...o4, delay: n4 + l2(s5) }).then(() => t5.notify("AnimationComplete", e4)));
                }), Promise.all(r4);
              }(t3, e3, o3 + s3, r3, a3, n3);
            } : () => Promise.resolve(), { when: a2 } = i2;
            if (a2) {
              const [t4, e4] = "beforeChildren" === a2 ? [o2, r2] : [r2, o2];
              return t4().then(() => e4());
            }
            return Promise.all([o2(), r2(n3.delay)]);
          }
          function Ue(t3, e3) {
            return t3.sortNodePosition(e3);
          }
          function Ne(t3, e3, n3 = {}) {
            let s2;
            if (t3.notify("AnimationStart", e3), Array.isArray(e3)) {
              const i2 = e3.map((e4) => Ie(t3, e4, n3));
              s2 = Promise.all(i2);
            } else if ("string" == typeof e3)
              s2 = Ie(t3, e3, n3);
            else {
              const i2 = "function" == typeof e3 ? xt(t3, e3, n3.custom) : e3;
              s2 = Promise.all(Oe(t3, i2, n3));
            }
            return s2.then(() => t3.notify("AnimationComplete", e3));
          }
          function $e() {
            let t3 = false;
            const e3 = /* @__PURE__ */ new Set(), n3 = { subscribe: (t4) => (e3.add(t4), () => {
              e3.delete(t4);
            }), start(n4, s2) {
              r(t3, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
              const i2 = [];
              return e3.forEach((t4) => {
                i2.push(Ne(t4, n4, { transitionOverride: s2 }));
              }), Promise.all(i2);
            }, set: (n4) => (r(t3, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."), e3.forEach((t4) => {
              !function(t5, e4) {
                Array.isArray(e4) ? Tt(t5, e4) : "string" == typeof e4 ? Tt(t5, [e4]) : bt(t5, e4);
              }(t4, n4);
            })), stop() {
              e3.forEach((t4) => {
                !function(t5) {
                  t5.values.forEach((t6) => t6.stop());
                }(t4);
              });
            }, mount: () => (t3 = true, () => {
              t3 = false, n3.stop();
            }) };
            return n3;
          }
          function We(e3) {
            const n3 = (0, t2.useRef)(null);
            return null === n3.current && (n3.current = e3()), n3.current;
          }
          const He = "undefined" != typeof document, ze = He ? t2.useLayoutEffect : t2.useEffect, Ye = (0, t2.createContext)({ transformPagePoint: (t3) => t3, isStatic: false, reducedMotion: "never" }), Xe = (0, t2.createContext)({}), Ge = (0, t2.createContext)(null), qe = (0, t2.createContext)({ strict: false });
          function Ze(t3) {
            return "object" == typeof t3 && Object.prototype.hasOwnProperty.call(t3, "current");
          }
          function Ke(t3) {
            return "string" == typeof t3 || Array.isArray(t3);
          }
          function _e(t3) {
            return "object" == typeof t3 && "function" == typeof t3.start;
          }
          const Je = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Qe = ["initial", ...Je];
          function tn(t3) {
            return _e(t3.animate) || Qe.some((e3) => Ke(t3[e3]));
          }
          function en(t3) {
            return Boolean(tn(t3) || t3.variants);
          }
          function nn(t3) {
            return Array.isArray(t3) ? t3.join(" ") : t3;
          }
          const sn = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, on = {};
          for (const t3 in sn)
            on[t3] = { isEnabled: (e3) => sn[t3].some((t4) => !!e3[t4]) };
          const rn = (0, t2.createContext)({}), an = (0, t2.createContext)({}), ln = Symbol.for("motionComponentSymbol");
          function un({ preloadedFeatures: e3, createVisualElement: n3, useRender: s2, useVisualState: i2, Component: o2 }) {
            e3 && function(t3) {
              for (const e4 in t3)
                on[e4] = { ...on[e4], ...t3[e4] };
            }(e3);
            const r2 = (0, t2.forwardRef)(function(r3, a2) {
              let l2;
              const u2 = { ...(0, t2.useContext)(Ye), ...r3, layoutId: cn(r3) }, { isStatic: c2 } = u2, h2 = function(e4) {
                const { initial: n4, animate: s3 } = function(t3, e5) {
                  if (tn(t3)) {
                    const { initial: e6, animate: n5 } = t3;
                    return { initial: false === e6 || Ke(e6) ? e6 : void 0, animate: Ke(n5) ? n5 : void 0 };
                  }
                  return false !== t3.inherit ? e5 : {};
                }(e4, (0, t2.useContext)(Xe));
                return (0, t2.useMemo)(() => ({ initial: n4, animate: s3 }), [nn(n4), nn(s3)]);
              }(r3), d2 = i2(r3, c2);
              if (!c2 && He) {
                h2.visualElement = function(e4, n4, s4, i4) {
                  const { visualElement: o3 } = (0, t2.useContext)(Xe), r4 = (0, t2.useContext)(qe), a3 = (0, t2.useContext)(Ge), l3 = (0, t2.useContext)(Ye).reducedMotion, u3 = (0, t2.useRef)();
                  i4 = i4 || r4.renderer, !u3.current && i4 && (u3.current = i4(e4, { visualState: n4, parent: o3, props: s4, presenceContext: a3, blockInitialAnimation: !!a3 && false === a3.initial, reducedMotionConfig: l3 }));
                  const c3 = u3.current;
                  (0, t2.useInsertionEffect)(() => {
                    c3 && c3.update(s4, a3);
                  });
                  const h3 = (0, t2.useRef)(Boolean(window.HandoffAppearAnimations));
                  return ze(() => {
                    c3 && (c3.render(), h3.current && c3.animationState && c3.animationState.animateChanges());
                  }), (0, t2.useEffect)(() => {
                    c3 && (c3.updateFeatures(), !h3.current && c3.animationState && c3.animationState.animateChanges(), window.HandoffAppearAnimations = void 0, h3.current = false);
                  }), c3;
                }(o2, d2, u2, n3);
                const s3 = (0, t2.useContext)(an), i3 = (0, t2.useContext)(qe).strict;
                h2.visualElement && (l2 = h2.visualElement.loadFeatures(u2, i3, e3, s3));
              }
              return t2.createElement(Xe.Provider, { value: h2 }, l2 && h2.visualElement ? t2.createElement(l2, { visualElement: h2.visualElement, ...u2 }) : null, s2(o2, r3, function(e4, n4, s3) {
                return (0, t2.useCallback)((t3) => {
                  t3 && e4.mount && e4.mount(t3), n4 && (t3 ? n4.mount(t3) : n4.unmount()), s3 && ("function" == typeof s3 ? s3(t3) : Ze(s3) && (s3.current = t3));
                }, [n4]);
              }(d2, h2.visualElement, a2), d2, c2, h2.visualElement));
            });
            return r2[ln] = o2, r2;
          }
          function cn({ layoutId: e3 }) {
            const n3 = (0, t2.useContext)(rn).id;
            return n3 && void 0 !== e3 ? n3 + "-" + e3 : e3;
          }
          function hn(t3) {
            function e3(e4, n4 = {}) {
              return un(t3(e4, n4));
            }
            if ("undefined" == typeof Proxy)
              return e3;
            const n3 = /* @__PURE__ */ new Map();
            return new Proxy(e3, { get: (t4, s2) => (n3.has(s2) || n3.set(s2, e3(s2)), n3.get(s2)) });
          }
          const dn = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
          function mn(t3) {
            return "string" == typeof t3 && !t3.includes("-") && !!(dn.indexOf(t3) > -1 || /[A-Z]/.test(t3));
          }
          const pn = {};
          function fn(t3, { layout: e3, layoutId: n3 }) {
            return Et.has(t3) || t3.startsWith("origin") || (e3 || void 0 !== n3) && (!!pn[t3] || "opacity" === t3);
          }
          const gn = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, yn = wt.length, vn = (t3, e3) => e3 && "number" == typeof t3 ? e3.transform(t3) : t3;
          function xn(t3, e3, n3, s2) {
            const { style: i2, vars: o2, transform: r2, transformOrigin: a2 } = t3;
            let l2 = false, u2 = false, c2 = true;
            for (const t4 in e3) {
              const n4 = e3[t4];
              if (E(t4)) {
                o2[t4] = n4;
                continue;
              }
              const s3 = ct[t4], h2 = vn(n4, s3);
              if (Et.has(t4)) {
                if (l2 = true, r2[t4] = h2, !c2)
                  continue;
                n4 !== (s3.default || 0) && (c2 = false);
              } else
                t4.startsWith("origin") ? (u2 = true, a2[t4] = h2) : i2[t4] = h2;
            }
            if (e3.transform || (l2 || s2 ? i2.transform = function(t4, { enableHardwareAcceleration: e4 = true, allowTransformNone: n4 = true }, s3, i3) {
              let o3 = "";
              for (let e5 = 0; e5 < yn; e5++) {
                const n5 = wt[e5];
                void 0 !== t4[n5] && (o3 += `${gn[n5] || n5}(${t4[n5]}) `);
              }
              return e4 && !t4.z && (o3 += "translateZ(0)"), o3 = o3.trim(), i3 ? o3 = i3(t4, s3 ? "" : o3) : n4 && s3 && (o3 = "none"), o3;
            }(t3.transform, n3, c2, s2) : i2.transform && (i2.transform = "none")), u2) {
              const { originX: t4 = "50%", originY: e4 = "50%", originZ: n4 = 0 } = a2;
              i2.transformOrigin = `${t4} ${e4} ${n4}`;
            }
          }
          function Pn(t3, e3, n3) {
            for (const s2 in e3)
              je(e3[s2]) || fn(s2, n3) || (t3[s2] = e3[s2]);
          }
          function bn(e3, n3, s2) {
            const i2 = {}, o2 = function(e4, n4, s3) {
              const i3 = {};
              return Pn(i3, e4.style || {}, e4), Object.assign(i3, function({ transformTemplate: e5 }, n5, s4) {
                return (0, t2.useMemo)(() => {
                  const t3 = { style: {}, transform: {}, transformOrigin: {}, vars: {} };
                  return xn(t3, n5, { enableHardwareAcceleration: !s4 }, e5), Object.assign({}, t3.vars, t3.style);
                }, [n5]);
              }(e4, n4, s3)), e4.transformValues ? e4.transformValues(i3) : i3;
            }(e3, n3, s2);
            return e3.drag && false !== e3.dragListener && (i2.draggable = false, o2.userSelect = o2.WebkitUserSelect = o2.WebkitTouchCallout = "none", o2.touchAction = true === e3.drag ? "none" : "pan-" + ("x" === e3.drag ? "y" : "x")), void 0 === e3.tabIndex && (e3.onTap || e3.onTapStart || e3.whileTap) && (i2.tabIndex = 0), i2.style = o2, i2;
          }
          const Tn = /* @__PURE__ */ new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]);
          function Sn(t3) {
            return t3.startsWith("while") || t3.startsWith("drag") && "draggable" !== t3 || t3.startsWith("layout") || t3.startsWith("onTap") || t3.startsWith("onPan") || Tn.has(t3);
          }
          let wn = (t3) => !Sn(t3);
          try {
            (En = (init_is_prop_valid_browser_esm(), __toCommonJS(is_prop_valid_browser_esm_exports)).default) && (wn = (t3) => t3.startsWith("on") ? !Sn(t3) : En(t3));
          } catch (t3) {
          }
          var En;
          function An(t3, e3, n3) {
            return "string" == typeof t3 ? t3 : z.transform(e3 + n3 * t3);
          }
          const Vn = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, Cn = { offset: "strokeDashoffset", array: "strokeDasharray" };
          function Mn(t3, { attrX: e3, attrY: n3, attrScale: s2, originX: i2, originY: o2, pathLength: r2, pathSpacing: a2 = 1, pathOffset: l2 = 0, ...u2 }, c2, h2, d2) {
            if (xn(t3, u2, c2, d2), h2)
              return void (t3.style.viewBox && (t3.attrs.viewBox = t3.style.viewBox));
            t3.attrs = t3.style, t3.style = {};
            const { attrs: m2, style: p2, dimensions: f2 } = t3;
            m2.transform && (f2 && (p2.transform = m2.transform), delete m2.transform), f2 && (void 0 !== i2 || void 0 !== o2 || p2.transform) && (p2.transformOrigin = function(t4, e4, n4) {
              return `${An(e4, t4.x, t4.width)} ${An(n4, t4.y, t4.height)}`;
            }(f2, void 0 !== i2 ? i2 : 0.5, void 0 !== o2 ? o2 : 0.5)), void 0 !== e3 && (m2.x = e3), void 0 !== n3 && (m2.y = n3), void 0 !== s2 && (m2.scale = s2), void 0 !== r2 && function(t4, e4, n4 = 1, s3 = 0, i3 = true) {
              t4.pathLength = 1;
              const o3 = i3 ? Vn : Cn;
              t4[o3.offset] = z.transform(-s3);
              const r3 = z.transform(e4), a3 = z.transform(n4);
              t4[o3.array] = `${r3} ${a3}`;
            }(m2, r2, a2, l2, false);
          }
          const Dn = (t3) => "string" == typeof t3 && "svg" === t3.toLowerCase();
          function kn(e3, n3, s2, i2) {
            const o2 = (0, t2.useMemo)(() => {
              const t3 = { style: {}, transform: {}, transformOrigin: {}, vars: {}, attrs: {} };
              return Mn(t3, n3, { enableHardwareAcceleration: false }, Dn(i2), e3.transformTemplate), { ...t3.attrs, style: { ...t3.style } };
            }, [n3]);
            if (e3.style) {
              const t3 = {};
              Pn(t3, e3.style, e3), o2.style = { ...t3, ...o2.style };
            }
            return o2;
          }
          function Rn(e3 = false) {
            return (n3, s2, i2, { latestValues: o2 }, r2) => {
              const a2 = (mn(n3) ? kn : bn)(s2, o2, r2, n3), l2 = { ...function(t3, e4, n4) {
                const s3 = {};
                for (const i3 in t3)
                  "values" === i3 && "object" == typeof t3.values || (wn(i3) || true === n4 && Sn(i3) || !e4 && !Sn(i3) || t3.draggable && i3.startsWith("onDrag")) && (s3[i3] = t3[i3]);
                return s3;
              }(s2, "string" == typeof n3, e3), ...a2, ref: i2 }, { children: u2 } = s2, c2 = (0, t2.useMemo)(() => je(u2) ? u2.get() : u2, [u2]);
              return (0, t2.createElement)(n3, { ...l2, children: c2 });
            };
          }
          function Ln(t3, { style: e3, vars: n3 }, s2, i2) {
            Object.assign(t3.style, e3, i2 && i2.getProjectionStyles(s2));
            for (const e4 in n3)
              t3.style.setProperty(e4, n3[e4]);
          }
          const jn = /* @__PURE__ */ new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
          function Bn(t3, e3, n3, s2) {
            Ln(t3, e3, void 0, s2);
            for (const n4 in e3.attrs)
              t3.setAttribute(jn.has(n4) ? n4 : At(n4), e3.attrs[n4]);
          }
          function Fn(t3, e3) {
            const { style: n3 } = t3, s2 = {};
            for (const i2 in n3)
              (je(n3[i2]) || e3.style && je(e3.style[i2]) || fn(i2, t3)) && (s2[i2] = n3[i2]);
            return s2;
          }
          function On(t3, e3) {
            const n3 = Fn(t3, e3);
            for (const s2 in t3)
              (je(t3[s2]) || je(e3[s2])) && (n3[-1 !== wt.indexOf(s2) ? "attr" + s2.charAt(0).toUpperCase() + s2.substring(1) : s2] = t3[s2]);
            return n3;
          }
          function In(t3) {
            const e3 = je(t3) ? t3.get() : t3;
            return n3 = e3, Boolean(n3 && "object" == typeof n3 && n3.mix && n3.toValue) ? e3.toValue() : e3;
            var n3;
          }
          const Un = (e3) => (n3, s2) => {
            const i2 = (0, t2.useContext)(Xe), o2 = (0, t2.useContext)(Ge), r2 = () => function({ scrapeMotionValuesFromProps: t3, createRenderState: e4, onMount: n4 }, s3, i3, o3) {
              const r3 = { latestValues: Nn(s3, i3, o3, t3), renderState: e4() };
              return n4 && (r3.mount = (t4) => n4(s3, t4, r3)), r3;
            }(e3, n3, i2, o2);
            return s2 ? r2() : We(r2);
          };
          function Nn(t3, e3, n3, s2) {
            const i2 = {}, o2 = s2(t3, {});
            for (const t4 in o2)
              i2[t4] = In(o2[t4]);
            let { initial: r2, animate: a2 } = t3;
            const l2 = tn(t3), u2 = en(t3);
            e3 && u2 && !l2 && false !== t3.inherit && (void 0 === r2 && (r2 = e3.initial), void 0 === a2 && (a2 = e3.animate));
            let c2 = !!n3 && false === n3.initial;
            c2 = c2 || false === r2;
            const h2 = c2 ? a2 : r2;
            return h2 && "boolean" != typeof h2 && !_e(h2) && (Array.isArray(h2) ? h2 : [h2]).forEach((e4) => {
              const n4 = vt(t3, e4);
              if (!n4)
                return;
              const { transitionEnd: s3, transition: o3, ...r3 } = n4;
              for (const t4 in r3) {
                let e5 = r3[t4];
                Array.isArray(e5) && (e5 = e5[c2 ? e5.length - 1 : 0]), null !== e5 && (i2[t4] = e5);
              }
              for (const t4 in s3)
                i2[t4] = s3[t4];
            }), i2;
          }
          const $n = { useVisualState: Un({ scrapeMotionValuesFromProps: On, createRenderState: () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {}, attrs: {} }), onMount: (t3, e3, { renderState: n3, latestValues: s2 }) => {
            y.read(() => {
              try {
                n3.dimensions = "function" == typeof e3.getBBox ? e3.getBBox() : e3.getBoundingClientRect();
              } catch (t4) {
                n3.dimensions = { x: 0, y: 0, width: 0, height: 0 };
              }
            }), y.render(() => {
              Mn(n3, s2, { enableHardwareAcceleration: false }, Dn(e3.tagName), t3.transformTemplate), Bn(e3, n3);
            });
          } }) }, Wn = { useVisualState: Un({ scrapeMotionValuesFromProps: Fn, createRenderState: () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }) }) };
          function Hn(t3, e3, n3, s2 = { passive: true }) {
            return t3.addEventListener(e3, n3, s2), () => t3.removeEventListener(e3, n3);
          }
          const zn = (t3) => "mouse" === t3.pointerType ? "number" != typeof t3.button || t3.button <= 0 : false !== t3.isPrimary;
          function Yn(t3, e3 = "page") {
            return { point: { x: t3[e3 + "X"], y: t3[e3 + "Y"] } };
          }
          function Xn(t3, e3, n3, s2) {
            return Hn(t3, e3, /* @__PURE__ */ ((t4) => (e4) => zn(e4) && t4(e4, Yn(e4)))(n3), s2);
          }
          function Gn(t3) {
            let e3 = null;
            return () => null === e3 && (e3 = t3, () => {
              e3 = null;
            });
          }
          const qn = Gn("dragHorizontal"), Zn = Gn("dragVertical");
          function Kn(t3) {
            let e3 = false;
            if ("y" === t3)
              e3 = Zn();
            else if ("x" === t3)
              e3 = qn();
            else {
              const t4 = qn(), n3 = Zn();
              t4 && n3 ? e3 = () => {
                t4(), n3();
              } : (t4 && t4(), n3 && n3());
            }
            return e3;
          }
          function _n() {
            const t3 = Kn(true);
            return !t3 || (t3(), false);
          }
          class Jn {
            constructor(t3) {
              this.isMounted = false, this.node = t3;
            }
            update() {
            }
          }
          function Qn(t3, e3) {
            const n3 = "pointer" + (e3 ? "enter" : "leave"), s2 = "onHover" + (e3 ? "Start" : "End");
            return Xn(t3.current, n3, (n4, i2) => {
              if ("touch" === n4.type || _n())
                return;
              const o2 = t3.getProps();
              t3.animationState && o2.whileHover && t3.animationState.setActive("whileHover", e3), o2[s2] && y.update(() => o2[s2](n4, i2));
            }, { passive: !t3.getProps()[s2] });
          }
          const ts = (t3, e3) => !!e3 && (t3 === e3 || ts(t3, e3.parentElement));
          function es(t3, e3) {
            if (!e3)
              return;
            const n3 = new PointerEvent("pointer" + t3);
            e3(n3, Yn(n3));
          }
          const ns = /* @__PURE__ */ new WeakMap(), ss = /* @__PURE__ */ new WeakMap(), is = (t3) => {
            const e3 = ns.get(t3.target);
            e3 && e3(t3);
          }, os = (t3) => {
            t3.forEach(is);
          };
          const rs = { some: 0, all: 1 }, as = { inView: { Feature: class extends Jn {
            constructor() {
              super(...arguments), this.hasEnteredView = false, this.isInView = false;
            }
            startObserver() {
              this.unmount();
              const { viewport: t3 = {} } = this.node.getProps(), { root: e3, margin: n3, amount: s2 = "some", once: i2 } = t3, o2 = { root: e3 ? e3.current : void 0, rootMargin: n3, threshold: "number" == typeof s2 ? s2 : rs[s2] };
              return function(t4, e4, n4) {
                const s3 = function({ root: t5, ...e5 }) {
                  const n5 = t5 || document;
                  ss.has(n5) || ss.set(n5, {});
                  const s4 = ss.get(n5), i3 = JSON.stringify(e5);
                  return s4[i3] || (s4[i3] = new IntersectionObserver(os, { root: t5, ...e5 })), s4[i3];
                }(e4);
                return ns.set(t4, n4), s3.observe(t4), () => {
                  ns.delete(t4), s3.unobserve(t4);
                };
              }(this.node.current, o2, (t4) => {
                const { isIntersecting: e4 } = t4;
                if (this.isInView === e4)
                  return;
                if (this.isInView = e4, i2 && !e4 && this.hasEnteredView)
                  return;
                e4 && (this.hasEnteredView = true), this.node.animationState && this.node.animationState.setActive("whileInView", e4);
                const { onViewportEnter: n4, onViewportLeave: s3 } = this.node.getProps(), o3 = e4 ? n4 : s3;
                o3 && o3(t4);
              });
            }
            mount() {
              this.startObserver();
            }
            update() {
              if ("undefined" == typeof IntersectionObserver)
                return;
              const { props: t3, prevProps: e3 } = this.node;
              ["amount", "margin", "root"].some(function({ viewport: t4 = {} }, { viewport: e4 = {} } = {}) {
                return (n3) => t4[n3] !== e4[n3];
              }(t3, e3)) && this.startObserver();
            }
            unmount() {
            }
          } }, tap: { Feature: class extends Jn {
            constructor() {
              super(...arguments), this.removeStartListeners = n2, this.removeEndListeners = n2, this.removeAccessibleListeners = n2, this.startPointerPress = (t3, e3) => {
                if (this.removeEndListeners(), this.isPressing)
                  return;
                const n3 = this.node.getProps(), s2 = Xn(window, "pointerup", (t4, e4) => {
                  if (!this.checkPressEnd())
                    return;
                  const { onTap: n4, onTapCancel: s3 } = this.node.getProps();
                  y.update(() => {
                    ts(this.node.current, t4.target) ? n4 && n4(t4, e4) : s3 && s3(t4, e4);
                  });
                }, { passive: !(n3.onTap || n3.onPointerUp) }), i2 = Xn(window, "pointercancel", (t4, e4) => this.cancelPress(t4, e4), { passive: !(n3.onTapCancel || n3.onPointerCancel) });
                this.removeEndListeners = se(s2, i2), this.startPress(t3, e3);
              }, this.startAccessiblePress = () => {
                const t3 = Hn(this.node.current, "keydown", (t4) => {
                  "Enter" !== t4.key || this.isPressing || (this.removeEndListeners(), this.removeEndListeners = Hn(this.node.current, "keyup", (t5) => {
                    "Enter" === t5.key && this.checkPressEnd() && es("up", (t6, e4) => {
                      const { onTap: n3 } = this.node.getProps();
                      n3 && y.update(() => n3(t6, e4));
                    });
                  }), es("down", (t5, e4) => {
                    this.startPress(t5, e4);
                  }));
                }), e3 = Hn(this.node.current, "blur", () => {
                  this.isPressing && es("cancel", (t4, e4) => this.cancelPress(t4, e4));
                });
                this.removeAccessibleListeners = se(t3, e3);
              };
            }
            startPress(t3, e3) {
              this.isPressing = true;
              const { onTapStart: n3, whileTap: s2 } = this.node.getProps();
              s2 && this.node.animationState && this.node.animationState.setActive("whileTap", true), n3 && y.update(() => n3(t3, e3));
            }
            checkPressEnd() {
              return this.removeEndListeners(), this.isPressing = false, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", false), !_n();
            }
            cancelPress(t3, e3) {
              if (!this.checkPressEnd())
                return;
              const { onTapCancel: n3 } = this.node.getProps();
              n3 && y.update(() => n3(t3, e3));
            }
            mount() {
              const t3 = this.node.getProps(), e3 = Xn(this.node.current, "pointerdown", this.startPointerPress, { passive: !(t3.onTapStart || t3.onPointerStart) }), n3 = Hn(this.node.current, "focus", this.startAccessiblePress);
              this.removeStartListeners = se(e3, n3);
            }
            unmount() {
              this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
            }
          } }, focus: { Feature: class extends Jn {
            constructor() {
              super(...arguments), this.isActive = false;
            }
            onFocus() {
              let t3 = false;
              try {
                t3 = this.node.current.matches(":focus-visible");
              } catch (e3) {
                t3 = true;
              }
              t3 && this.node.animationState && (this.node.animationState.setActive("whileFocus", true), this.isActive = true);
            }
            onBlur() {
              this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", false), this.isActive = false);
            }
            mount() {
              this.unmount = se(Hn(this.node.current, "focus", () => this.onFocus()), Hn(this.node.current, "blur", () => this.onBlur()));
            }
            unmount() {
            }
          } }, hover: { Feature: class extends Jn {
            mount() {
              this.unmount = se(Qn(this.node, true), Qn(this.node, false));
            }
            unmount() {
            }
          } } };
          function ls(t3, e3) {
            if (!Array.isArray(e3))
              return false;
            const n3 = e3.length;
            if (n3 !== t3.length)
              return false;
            for (let s2 = 0; s2 < n3; s2++)
              if (e3[s2] !== t3[s2])
                return false;
            return true;
          }
          const us = [...Je].reverse(), cs = Je.length;
          function hs(t3 = false) {
            return { isActive: t3, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} };
          }
          let ds = 0;
          const ms = { animation: { Feature: class extends Jn {
            constructor(t3) {
              super(t3), t3.animationState || (t3.animationState = function(t4) {
                let e3 = /* @__PURE__ */ function(t5) {
                  return (e4) => Promise.all(e4.map(({ animation: e5, options: n4 }) => Ne(t5, e5, n4)));
                }(t4);
                const n3 = { animate: hs(true), whileInView: hs(), whileHover: hs(), whileTap: hs(), whileDrag: hs(), whileFocus: hs(), exit: hs() };
                let s2 = true;
                const i2 = (e4, n4) => {
                  const s3 = xt(t4, n4);
                  if (s3) {
                    const { transition: t5, transitionEnd: n5, ...i3 } = s3;
                    e4 = { ...e4, ...i3, ...n5 };
                  }
                  return e4;
                };
                function o2(o3, r2) {
                  const a2 = t4.getProps(), l2 = t4.getVariantContext(true) || {}, u2 = [], h2 = /* @__PURE__ */ new Set();
                  let d2 = {}, m2 = 1 / 0;
                  for (let e4 = 0; e4 < cs; e4++) {
                    const g3 = us[e4], y2 = n3[g3], v2 = void 0 !== a2[g3] ? a2[g3] : l2[g3], x2 = Ke(v2), P2 = g3 === r2 ? y2.isActive : null;
                    false === P2 && (m2 = e4);
                    let b2 = v2 === l2[g3] && v2 !== a2[g3] && x2;
                    if (b2 && s2 && t4.manuallyAnimateOnMount && (b2 = false), y2.protectedKeys = { ...d2 }, !y2.isActive && null === P2 || !v2 && !y2.prevProp || _e(v2) || "boolean" == typeof v2)
                      continue;
                    const T2 = (p2 = y2.prevProp, "string" == typeof (f2 = v2) ? f2 !== p2 : !!Array.isArray(f2) && !ls(f2, p2));
                    let S2 = T2 || g3 === r2 && y2.isActive && !b2 && x2 || e4 > m2 && x2;
                    const w2 = Array.isArray(v2) ? v2 : [v2];
                    let E2 = w2.reduce(i2, {});
                    false === P2 && (E2 = {});
                    const { prevResolvedValues: A2 = {} } = y2, V2 = { ...A2, ...E2 }, C2 = (t5) => {
                      S2 = true, h2.delete(t5), y2.needsAnimating[t5] = true;
                    };
                    for (const t5 in V2) {
                      const e5 = E2[t5], n4 = A2[t5];
                      d2.hasOwnProperty(t5) || (e5 !== n4 ? c(e5) && c(n4) ? !ls(e5, n4) || T2 ? C2(t5) : y2.protectedKeys[t5] = true : void 0 !== e5 ? C2(t5) : h2.add(t5) : void 0 !== e5 && h2.has(t5) ? C2(t5) : y2.protectedKeys[t5] = true);
                    }
                    y2.prevProp = v2, y2.prevResolvedValues = E2, y2.isActive && (d2 = { ...d2, ...E2 }), s2 && t4.blockInitialAnimation && (S2 = false), S2 && !b2 && u2.push(...w2.map((t5) => ({ animation: t5, options: { type: g3, ...o3 } })));
                  }
                  var p2, f2;
                  if (h2.size) {
                    const e4 = {};
                    h2.forEach((n4) => {
                      const s3 = t4.getBaseTarget(n4);
                      void 0 !== s3 && (e4[n4] = s3);
                    }), u2.push({ animation: e4 });
                  }
                  let g2 = Boolean(u2.length);
                  return s2 && false === a2.initial && !t4.manuallyAnimateOnMount && (g2 = false), s2 = false, g2 ? e3(u2) : Promise.resolve();
                }
                return { animateChanges: o2, setActive: function(e4, s3, i3) {
                  var r2;
                  if (n3[e4].isActive === s3)
                    return Promise.resolve();
                  null === (r2 = t4.variantChildren) || void 0 === r2 || r2.forEach((t5) => {
                    var n4;
                    return null === (n4 = t5.animationState) || void 0 === n4 ? void 0 : n4.setActive(e4, s3);
                  }), n3[e4].isActive = s3;
                  const a2 = o2(i3, e4);
                  for (const t5 in n3)
                    n3[t5].protectedKeys = {};
                  return a2;
                }, setAnimateFunction: function(n4) {
                  e3 = n4(t4);
                }, getState: () => n3 };
              }(t3));
            }
            updateAnimationControlsSubscription() {
              const { animate: t3 } = this.node.getProps();
              this.unmount(), _e(t3) && (this.unmount = t3.subscribe(this.node));
            }
            mount() {
              this.updateAnimationControlsSubscription();
            }
            update() {
              const { animate: t3 } = this.node.getProps(), { animate: e3 } = this.node.prevProps || {};
              t3 !== e3 && this.updateAnimationControlsSubscription();
            }
            unmount() {
            }
          } }, exit: { Feature: class extends Jn {
            constructor() {
              super(...arguments), this.id = ds++;
            }
            update() {
              if (!this.node.presenceContext)
                return;
              const { isPresent: t3, onExitComplete: e3, custom: n3 } = this.node.presenceContext, { isPresent: s2 } = this.node.prevPresenceContext || {};
              if (!this.node.animationState || t3 === s2)
                return;
              const i2 = this.node.animationState.setActive("exit", !t3, { custom: null != n3 ? n3 : this.node.getProps().custom });
              e3 && !t3 && i2.then(() => e3(this.id));
            }
            mount() {
              const { register: t3 } = this.node.presenceContext || {};
              t3 && (this.unmount = t3(this.id));
            }
            unmount() {
            }
          } } }, ps = (t3, e3) => Math.abs(t3 - e3);
          class fs {
            constructor(t3, e3, { transformPagePoint: n3 } = {}) {
              if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
                if (!this.lastMoveEvent || !this.lastMoveEventInfo)
                  return;
                const t4 = vs(this.lastMoveEventInfo, this.history), e4 = null !== this.startEvent, n4 = function(t5, e5) {
                  const n5 = ps(t5.x, e5.x), s4 = ps(t5.y, e5.y);
                  return Math.sqrt(n5 ** 2 + s4 ** 2);
                }(t4.offset, { x: 0, y: 0 }) >= 3;
                if (!e4 && !n4)
                  return;
                const { point: s3 } = t4, { timestamp: i3 } = x;
                this.history.push({ ...s3, timestamp: i3 });
                const { onStart: o3, onMove: r3 } = this.handlers;
                e4 || (o3 && o3(this.lastMoveEvent, t4), this.startEvent = this.lastMoveEvent), r3 && r3(this.lastMoveEvent, t4);
              }, this.handlePointerMove = (t4, e4) => {
                this.lastMoveEvent = t4, this.lastMoveEventInfo = gs(e4, this.transformPagePoint), y.update(this.updatePoint, true);
              }, this.handlePointerUp = (t4, e4) => {
                if (this.end(), !this.lastMoveEvent || !this.lastMoveEventInfo)
                  return;
                const { onEnd: n4, onSessionEnd: s3 } = this.handlers, i3 = vs("pointercancel" === t4.type ? this.lastMoveEventInfo : gs(e4, this.transformPagePoint), this.history);
                this.startEvent && n4 && n4(t4, i3), s3 && s3(t4, i3);
              }, !zn(t3))
                return;
              this.handlers = e3, this.transformPagePoint = n3;
              const s2 = gs(Yn(t3), this.transformPagePoint), { point: i2 } = s2, { timestamp: o2 } = x;
              this.history = [{ ...i2, timestamp: o2 }];
              const { onSessionStart: r2 } = e3;
              r2 && r2(t3, vs(s2, this.history)), this.removeListeners = se(Xn(window, "pointermove", this.handlePointerMove), Xn(window, "pointerup", this.handlePointerUp), Xn(window, "pointercancel", this.handlePointerUp));
            }
            updateHandlers(t3) {
              this.handlers = t3;
            }
            end() {
              this.removeListeners && this.removeListeners(), v(this.updatePoint);
            }
          }
          function gs(t3, e3) {
            return e3 ? { point: e3(t3.point) } : t3;
          }
          function ys(t3, e3) {
            return { x: t3.x - e3.x, y: t3.y - e3.y };
          }
          function vs({ point: t3 }, e3) {
            return { point: t3, delta: ys(t3, Ps(e3)), offset: ys(t3, xs(e3)), velocity: bs(e3, 0.1) };
          }
          function xs(t3) {
            return t3[0];
          }
          function Ps(t3) {
            return t3[t3.length - 1];
          }
          function bs(t3, e3) {
            if (t3.length < 2)
              return { x: 0, y: 0 };
            let n3 = t3.length - 1, s2 = null;
            const i2 = Ps(t3);
            for (; n3 >= 0 && (s2 = t3[n3], !(i2.timestamp - s2.timestamp > Ct(e3))); )
              n3--;
            if (!s2)
              return { x: 0, y: 0 };
            const o2 = Mt(i2.timestamp - s2.timestamp);
            if (0 === o2)
              return { x: 0, y: 0 };
            const r2 = { x: (i2.x - s2.x) / o2, y: (i2.y - s2.y) / o2 };
            return r2.x === 1 / 0 && (r2.x = 0), r2.y === 1 / 0 && (r2.y = 0), r2;
          }
          function Ts(t3) {
            return t3.max - t3.min;
          }
          function Ss(t3, e3 = 0, n3 = 0.01) {
            return Math.abs(t3 - e3) <= n3;
          }
          function ws(t3, e3, n3, s2 = 0.5) {
            t3.origin = s2, t3.originPoint = Kt(e3.min, e3.max, t3.origin), t3.scale = Ts(n3) / Ts(e3), (Ss(t3.scale, 1, 1e-4) || isNaN(t3.scale)) && (t3.scale = 1), t3.translate = Kt(n3.min, n3.max, t3.origin) - t3.originPoint, (Ss(t3.translate) || isNaN(t3.translate)) && (t3.translate = 0);
          }
          function Es(t3, e3, n3, s2) {
            ws(t3.x, e3.x, n3.x, s2 ? s2.originX : void 0), ws(t3.y, e3.y, n3.y, s2 ? s2.originY : void 0);
          }
          function As(t3, e3, n3) {
            t3.min = n3.min + e3.min, t3.max = t3.min + Ts(e3);
          }
          function Vs(t3, e3, n3) {
            t3.min = e3.min - n3.min, t3.max = t3.min + Ts(e3);
          }
          function Cs(t3, e3, n3) {
            Vs(t3.x, e3.x, n3.x), Vs(t3.y, e3.y, n3.y);
          }
          function Ms(t3, e3, n3) {
            return { min: void 0 !== e3 ? t3.min + e3 : void 0, max: void 0 !== n3 ? t3.max + n3 - (t3.max - t3.min) : void 0 };
          }
          function Ds(t3, e3) {
            let n3 = e3.min - t3.min, s2 = e3.max - t3.max;
            return e3.max - e3.min < t3.max - t3.min && ([n3, s2] = [s2, n3]), { min: n3, max: s2 };
          }
          const ks = 0.35;
          function Rs(t3, e3, n3) {
            return { min: Ls(t3, e3), max: Ls(t3, n3) };
          }
          function Ls(t3, e3) {
            return "number" == typeof t3 ? t3 : t3[e3] || 0;
          }
          function js(t3) {
            return [t3("x"), t3("y")];
          }
          function Bs({ top: t3, left: e3, right: n3, bottom: s2 }) {
            return { x: { min: e3, max: n3 }, y: { min: t3, max: s2 } };
          }
          function Fs(t3) {
            return void 0 === t3 || 1 === t3;
          }
          function Os({ scale: t3, scaleX: e3, scaleY: n3 }) {
            return !Fs(t3) || !Fs(e3) || !Fs(n3);
          }
          function Is(t3) {
            return Os(t3) || Us(t3) || t3.z || t3.rotate || t3.rotateX || t3.rotateY;
          }
          function Us(t3) {
            return Ns(t3.x) || Ns(t3.y);
          }
          function Ns(t3) {
            return t3 && "0%" !== t3;
          }
          function $s(t3, e3, n3) {
            return n3 + e3 * (t3 - n3);
          }
          function Ws(t3, e3, n3, s2, i2) {
            return void 0 !== i2 && (t3 = $s(t3, i2, s2)), $s(t3, n3, s2) + e3;
          }
          function Hs(t3, e3 = 0, n3 = 1, s2, i2) {
            t3.min = Ws(t3.min, e3, n3, s2, i2), t3.max = Ws(t3.max, e3, n3, s2, i2);
          }
          function zs(t3, { x: e3, y: n3 }) {
            Hs(t3.x, e3.translate, e3.scale, e3.originPoint), Hs(t3.y, n3.translate, n3.scale, n3.originPoint);
          }
          function Ys(t3) {
            return Number.isInteger(t3) || t3 > 1.0000000000001 || t3 < 0.999999999999 ? t3 : 1;
          }
          function Xs(t3, e3) {
            t3.min = t3.min + e3, t3.max = t3.max + e3;
          }
          function Gs(t3, e3, [n3, s2, i2]) {
            const o2 = void 0 !== e3[i2] ? e3[i2] : 0.5, r2 = Kt(t3.min, t3.max, o2);
            Hs(t3, e3[n3], e3[s2], r2, e3.scale);
          }
          const qs = ["x", "scaleX", "originX"], Zs = ["y", "scaleY", "originY"];
          function Ks(t3, e3) {
            Gs(t3.x, e3, qs), Gs(t3.y, e3, Zs);
          }
          function _s(t3, e3) {
            return Bs(function(t4, e4) {
              if (!e4)
                return t4;
              const n3 = e4({ x: t4.left, y: t4.top }), s2 = e4({ x: t4.right, y: t4.bottom });
              return { top: n3.y, left: n3.x, bottom: s2.y, right: s2.x };
            }(t3.getBoundingClientRect(), e3));
          }
          const Js = /* @__PURE__ */ new WeakMap();
          class Qs {
            constructor(t3) {
              this.openGlobalLock = null, this.isDragging = false, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = false, this.hasMutatedConstraints = false, this.elastic = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }, this.visualElement = t3;
            }
            start(t3, { snapToCursor: e3 = false } = {}) {
              const { presenceContext: n3 } = this.visualElement;
              n3 && false === n3.isPresent || (this.panSession = new fs(t3, { onSessionStart: (t4) => {
                this.stopAnimation(), e3 && this.snapToCursor(Yn(t4, "page").point);
              }, onStart: (t4, e4) => {
                const { drag: n4, dragPropagation: s2, onDragStart: i2 } = this.getProps();
                if (n4 && !s2 && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Kn(n4), !this.openGlobalLock))
                  return;
                this.isDragging = true, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = true, this.visualElement.projection.target = void 0), js((t5) => {
                  let e5 = this.getAxisMotionValue(t5).get() || 0;
                  if (H.test(e5)) {
                    const { projection: n5 } = this.visualElement;
                    if (n5 && n5.layout) {
                      const s3 = n5.layout.layoutBox[t5];
                      s3 && (e5 = Ts(s3) * (parseFloat(e5) / 100));
                    }
                  }
                  this.originPoint[t5] = e5;
                }), i2 && y.update(() => i2(t4, e4), false, true);
                const { animationState: o2 } = this.visualElement;
                o2 && o2.setActive("whileDrag", true);
              }, onMove: (t4, e4) => {
                const { dragPropagation: n4, dragDirectionLock: s2, onDirectionLock: i2, onDrag: o2 } = this.getProps();
                if (!n4 && !this.openGlobalLock)
                  return;
                const { offset: r2 } = e4;
                if (s2 && null === this.currentDirection)
                  return this.currentDirection = function(t5, e5 = 10) {
                    let n5 = null;
                    return Math.abs(t5.y) > e5 ? n5 = "y" : Math.abs(t5.x) > e5 && (n5 = "x"), n5;
                  }(r2), void (null !== this.currentDirection && i2 && i2(this.currentDirection));
                this.updateAxis("x", e4.point, r2), this.updateAxis("y", e4.point, r2), this.visualElement.render(), o2 && o2(t4, e4);
              }, onSessionEnd: (t4, e4) => this.stop(t4, e4) }, { transformPagePoint: this.visualElement.getTransformPagePoint() }));
            }
            stop(t3, e3) {
              const n3 = this.isDragging;
              if (this.cancel(), !n3)
                return;
              const { velocity: s2 } = e3;
              this.startAnimation(s2);
              const { onDragEnd: i2 } = this.getProps();
              i2 && y.update(() => i2(t3, e3));
            }
            cancel() {
              this.isDragging = false;
              const { projection: t3, animationState: e3 } = this.visualElement;
              t3 && (t3.isAnimationBlocked = false), this.panSession && this.panSession.end(), this.panSession = void 0;
              const { dragPropagation: n3 } = this.getProps();
              !n3 && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), e3 && e3.setActive("whileDrag", false);
            }
            updateAxis(t3, e3, n3) {
              const { drag: s2 } = this.getProps();
              if (!n3 || !ti(t3, s2, this.currentDirection))
                return;
              const i2 = this.getAxisMotionValue(t3);
              let o2 = this.originPoint[t3] + n3[t3];
              this.constraints && this.constraints[t3] && (o2 = function(t4, { min: e4, max: n4 }, s3) {
                return void 0 !== e4 && t4 < e4 ? t4 = s3 ? Kt(e4, t4, s3.min) : Math.max(t4, e4) : void 0 !== n4 && t4 > n4 && (t4 = s3 ? Kt(n4, t4, s3.max) : Math.min(t4, n4)), t4;
              }(o2, this.constraints[t3], this.elastic[t3])), i2.set(o2);
            }
            resolveConstraints() {
              const { dragConstraints: t3, dragElastic: e3 } = this.getProps(), { layout: n3 } = this.visualElement.projection || {}, s2 = this.constraints;
              t3 && Ze(t3) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : this.constraints = !(!t3 || !n3) && function(t4, { top: e4, left: n4, bottom: s3, right: i2 }) {
                return { x: Ms(t4.x, n4, i2), y: Ms(t4.y, e4, s3) };
              }(n3.layoutBox, t3), this.elastic = function(t4 = ks) {
                return false === t4 ? t4 = 0 : true === t4 && (t4 = ks), { x: Rs(t4, "left", "right"), y: Rs(t4, "top", "bottom") };
              }(e3), s2 !== this.constraints && n3 && this.constraints && !this.hasMutatedConstraints && js((t4) => {
                this.getAxisMotionValue(t4) && (this.constraints[t4] = function(t5, e4) {
                  const n4 = {};
                  return void 0 !== e4.min && (n4.min = e4.min - t5.min), void 0 !== e4.max && (n4.max = e4.max - t5.min), n4;
                }(n3.layoutBox[t4], this.constraints[t4]));
              });
            }
            resolveRefConstraints() {
              const { dragConstraints: t3, onMeasureDragConstraints: e3 } = this.getProps();
              if (!t3 || !Ze(t3))
                return false;
              const n3 = t3.current;
              r(null !== n3, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
              const { projection: s2 } = this.visualElement;
              if (!s2 || !s2.layout)
                return false;
              const i2 = function(t4, e4, n4) {
                const s3 = _s(t4, n4), { scroll: i3 } = e4;
                return i3 && (Xs(s3.x, i3.offset.x), Xs(s3.y, i3.offset.y)), s3;
              }(n3, s2.root, this.visualElement.getTransformPagePoint());
              let o2 = function(t4, e4) {
                return { x: Ds(t4.x, e4.x), y: Ds(t4.y, e4.y) };
              }(s2.layout.layoutBox, i2);
              if (e3) {
                const t4 = e3(function({ x: t5, y: e4 }) {
                  return { top: e4.min, right: t5.max, bottom: e4.max, left: t5.min };
                }(o2));
                this.hasMutatedConstraints = !!t4, t4 && (o2 = Bs(t4));
              }
              return o2;
            }
            startAnimation(t3) {
              const { drag: e3, dragMomentum: n3, dragElastic: s2, dragTransition: i2, dragSnapToOrigin: o2, onDragTransitionEnd: r2 } = this.getProps(), a2 = this.constraints || {}, l2 = js((r3) => {
                if (!ti(r3, e3, this.currentDirection))
                  return;
                let l3 = a2 && a2[r3] || {};
                o2 && (l3 = { min: 0, max: 0 });
                const u2 = s2 ? 200 : 1e6, c2 = s2 ? 40 : 1e7, h2 = { type: "inertia", velocity: n3 ? t3[r3] : 0, bounceStiffness: u2, bounceDamping: c2, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i2, ...l3 };
                return this.startAxisValueAnimation(r3, h2);
              });
              return Promise.all(l2).then(r2);
            }
            startAxisValueAnimation(t3, e3) {
              const n3 = this.getAxisMotionValue(t3);
              return n3.start(Le(t3, n3, 0, e3));
            }
            stopAnimation() {
              js((t3) => this.getAxisMotionValue(t3).stop());
            }
            getAxisMotionValue(t3) {
              const e3 = "_drag" + t3.toUpperCase(), n3 = this.visualElement.getProps();
              return n3[e3] || this.visualElement.getValue(t3, (n3.initial ? n3.initial[t3] : void 0) || 0);
            }
            snapToCursor(t3) {
              js((e3) => {
                const { drag: n3 } = this.getProps();
                if (!ti(e3, n3, this.currentDirection))
                  return;
                const { projection: s2 } = this.visualElement, i2 = this.getAxisMotionValue(e3);
                if (s2 && s2.layout) {
                  const { min: n4, max: o2 } = s2.layout.layoutBox[e3];
                  i2.set(t3[e3] - Kt(n4, o2, 0.5));
                }
              });
            }
            scalePositionWithinConstraints() {
              if (!this.visualElement.current)
                return;
              const { drag: t3, dragConstraints: e3 } = this.getProps(), { projection: n3 } = this.visualElement;
              if (!Ze(e3) || !n3 || !this.constraints)
                return;
              this.stopAnimation();
              const s2 = { x: 0, y: 0 };
              js((t4) => {
                const e4 = this.getAxisMotionValue(t4);
                if (e4) {
                  const n4 = e4.get();
                  s2[t4] = function(t5, e5) {
                    let n5 = 0.5;
                    const s3 = Ts(t5), i3 = Ts(e5);
                    return i3 > s3 ? n5 = ue(e5.min, e5.max - s3, t5.min) : s3 > i3 && (n5 = ue(t5.min, t5.max - i3, e5.min)), R(0, 1, n5);
                  }({ min: n4, max: n4 }, this.constraints[t4]);
                }
              });
              const { transformTemplate: i2 } = this.visualElement.getProps();
              this.visualElement.current.style.transform = i2 ? i2({}, "") : "none", n3.root && n3.root.updateScroll(), n3.updateLayout(), this.resolveConstraints(), js((e4) => {
                if (!ti(e4, t3, null))
                  return;
                const n4 = this.getAxisMotionValue(e4), { min: i3, max: o2 } = this.constraints[e4];
                n4.set(Kt(i3, o2, s2[e4]));
              });
            }
            addListeners() {
              if (!this.visualElement.current)
                return;
              Js.set(this.visualElement, this);
              const t3 = Xn(this.visualElement.current, "pointerdown", (t4) => {
                const { drag: e4, dragListener: n4 = true } = this.getProps();
                e4 && n4 && this.start(t4);
              }), e3 = () => {
                const { dragConstraints: t4 } = this.getProps();
                Ze(t4) && (this.constraints = this.resolveRefConstraints());
              }, { projection: n3 } = this.visualElement, s2 = n3.addEventListener("measure", e3);
              n3 && !n3.layout && (n3.root && n3.root.updateScroll(), n3.updateLayout()), e3();
              const i2 = Hn(window, "resize", () => this.scalePositionWithinConstraints()), o2 = n3.addEventListener("didUpdate", ({ delta: t4, hasLayoutChanged: e4 }) => {
                this.isDragging && e4 && (js((e5) => {
                  const n4 = this.getAxisMotionValue(e5);
                  n4 && (this.originPoint[e5] += t4[e5].translate, n4.set(n4.get() + t4[e5].translate));
                }), this.visualElement.render());
              });
              return () => {
                i2(), t3(), s2(), o2 && o2();
              };
            }
            getProps() {
              const t3 = this.visualElement.getProps(), { drag: e3 = false, dragDirectionLock: n3 = false, dragPropagation: s2 = false, dragConstraints: i2 = false, dragElastic: o2 = ks, dragMomentum: r2 = true } = t3;
              return { ...t3, drag: e3, dragDirectionLock: n3, dragPropagation: s2, dragConstraints: i2, dragElastic: o2, dragMomentum: r2 };
            }
          }
          function ti(t3, e3, n3) {
            return !(true !== e3 && e3 !== t3 || null !== n3 && n3 !== t3);
          }
          const ei = (t3) => (e3, n3) => {
            t3 && y.update(() => t3(e3, n3));
          }, ni = { hasAnimatedSinceResize: true, hasEverUpdated: false };
          function si(t3, e3) {
            return e3.max === e3.min ? 0 : t3 / (e3.max - e3.min) * 100;
          }
          const ii = { correct: (t3, e3) => {
            if (!e3.target)
              return t3;
            if ("string" == typeof t3) {
              if (!z.test(t3))
                return t3;
              t3 = parseFloat(t3);
            }
            return `${si(t3, e3.target.x)}% ${si(t3, e3.target.y)}%`;
          } }, oi = { correct: (t3, { treeScale: e3, projectionDelta: n3 }) => {
            const s2 = t3, i2 = it.parse(t3);
            if (i2.length > 5)
              return s2;
            const o2 = it.createTransformer(t3), r2 = "number" != typeof i2[0] ? 1 : 0, a2 = n3.x.scale * e3.x, l2 = n3.y.scale * e3.y;
            i2[0 + r2] /= a2, i2[1 + r2] /= l2;
            const u2 = Kt(a2, l2, 0.5);
            return "number" == typeof i2[2 + r2] && (i2[2 + r2] /= u2), "number" == typeof i2[3 + r2] && (i2[3 + r2] /= u2), o2(i2);
          } };
          class ri extends t2.Component {
            componentDidMount() {
              const { visualElement: t3, layoutGroup: e3, switchLayoutGroup: n3, layoutId: s2 } = this.props, { projection: i2 } = t3;
              var o2;
              o2 = li, Object.assign(pn, o2), i2 && (e3.group && e3.group.add(i2), n3 && n3.register && s2 && n3.register(i2), i2.root.didUpdate(), i2.addEventListener("animationComplete", () => {
                this.safeToRemove();
              }), i2.setOptions({ ...i2.options, onExitComplete: () => this.safeToRemove() })), ni.hasEverUpdated = true;
            }
            getSnapshotBeforeUpdate(t3) {
              const { layoutDependency: e3, visualElement: n3, drag: s2, isPresent: i2 } = this.props, o2 = n3.projection;
              return o2 ? (o2.isPresent = i2, s2 || t3.layoutDependency !== e3 || void 0 === e3 ? o2.willUpdate() : this.safeToRemove(), t3.isPresent !== i2 && (i2 ? o2.promote() : o2.relegate() || y.postRender(() => {
                const t4 = o2.getStack();
                t4 && t4.members.length || this.safeToRemove();
              })), null) : null;
            }
            componentDidUpdate() {
              const { projection: t3 } = this.props.visualElement;
              t3 && (t3.root.didUpdate(), queueMicrotask(() => {
                !t3.currentAnimation && t3.isLead() && this.safeToRemove();
              }));
            }
            componentWillUnmount() {
              const { visualElement: t3, layoutGroup: e3, switchLayoutGroup: n3 } = this.props, { projection: s2 } = t3;
              s2 && (s2.scheduleCheckAfterUnmount(), e3 && e3.group && e3.group.remove(s2), n3 && n3.deregister && n3.deregister(s2));
            }
            safeToRemove() {
              const { safeToRemove: t3 } = this.props;
              t3 && t3();
            }
            render() {
              return null;
            }
          }
          function ai(e3) {
            const [n3, s2] = function() {
              const e4 = (0, t2.useContext)(Ge);
              if (null === e4)
                return [true, null];
              const { isPresent: n4, onExitComplete: s3, register: i3 } = e4, o2 = (0, t2.useId)();
              return (0, t2.useEffect)(() => i3(o2), []), !n4 && s3 ? [false, () => s3 && s3(o2)] : [true];
            }(), i2 = (0, t2.useContext)(rn);
            return t2.createElement(ri, { ...e3, layoutGroup: i2, switchLayoutGroup: (0, t2.useContext)(an), isPresent: n3, safeToRemove: s2 });
          }
          const li = { borderRadius: { ...ii, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: ii, borderTopRightRadius: ii, borderBottomLeftRadius: ii, borderBottomRightRadius: ii, boxShadow: oi }, ui = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], ci = ui.length, hi = (t3) => "string" == typeof t3 ? parseFloat(t3) : t3, di = (t3) => "number" == typeof t3 || z.test(t3);
          function mi(t3, e3) {
            return void 0 !== t3[e3] ? t3[e3] : t3.borderRadius;
          }
          const pi = gi(0, 0.5, Ht), fi = gi(0.5, 0.95, n2);
          function gi(t3, e3, n3) {
            return (s2) => s2 < t3 ? 0 : s2 > e3 ? 1 : n3(ue(t3, e3, s2));
          }
          function yi(t3, e3) {
            t3.min = e3.min, t3.max = e3.max;
          }
          function vi(t3, e3) {
            yi(t3.x, e3.x), yi(t3.y, e3.y);
          }
          function xi(t3, e3, n3, s2, i2) {
            return t3 = $s(t3 -= e3, 1 / n3, s2), void 0 !== i2 && (t3 = $s(t3, 1 / i2, s2)), t3;
          }
          function Pi(t3, e3, [n3, s2, i2], o2, r2) {
            !function(t4, e4 = 0, n4 = 1, s3 = 0.5, i3, o3 = t4, r3 = t4) {
              if (H.test(e4) && (e4 = parseFloat(e4), e4 = Kt(r3.min, r3.max, e4 / 100) - r3.min), "number" != typeof e4)
                return;
              let a2 = Kt(o3.min, o3.max, s3);
              t4 === o3 && (a2 -= e4), t4.min = xi(t4.min, e4, n4, a2, i3), t4.max = xi(t4.max, e4, n4, a2, i3);
            }(t3, e3[n3], e3[s2], e3[i2], e3.scale, o2, r2);
          }
          const bi = ["x", "scaleX", "originX"], Ti = ["y", "scaleY", "originY"];
          function Si(t3, e3, n3, s2) {
            Pi(t3.x, e3, bi, n3 ? n3.x : void 0, s2 ? s2.x : void 0), Pi(t3.y, e3, Ti, n3 ? n3.y : void 0, s2 ? s2.y : void 0);
          }
          function wi(t3) {
            return 0 === t3.translate && 1 === t3.scale;
          }
          function Ei(t3) {
            return wi(t3.x) && wi(t3.y);
          }
          function Ai(t3, e3) {
            return Math.round(t3.x.min) === Math.round(e3.x.min) && Math.round(t3.x.max) === Math.round(e3.x.max) && Math.round(t3.y.min) === Math.round(e3.y.min) && Math.round(t3.y.max) === Math.round(e3.y.max);
          }
          function Vi(t3) {
            return Ts(t3.x) / Ts(t3.y);
          }
          class Ci {
            constructor() {
              this.members = [];
            }
            add(t3) {
              h(this.members, t3), t3.scheduleRender();
            }
            remove(t3) {
              if (d(this.members, t3), t3 === this.prevLead && (this.prevLead = void 0), t3 === this.lead) {
                const t4 = this.members[this.members.length - 1];
                t4 && this.promote(t4);
              }
            }
            relegate(t3) {
              const e3 = this.members.findIndex((e4) => t3 === e4);
              if (0 === e3)
                return false;
              let n3;
              for (let t4 = e3; t4 >= 0; t4--) {
                const e4 = this.members[t4];
                if (false !== e4.isPresent) {
                  n3 = e4;
                  break;
                }
              }
              return !!n3 && (this.promote(n3), true);
            }
            promote(t3, e3) {
              const n3 = this.lead;
              if (t3 !== n3 && (this.prevLead = n3, this.lead = t3, t3.show(), n3)) {
                n3.instance && n3.scheduleRender(), t3.scheduleRender(), t3.resumeFrom = n3, e3 && (t3.resumeFrom.preserveOpacity = true), n3.snapshot && (t3.snapshot = n3.snapshot, t3.snapshot.latestValues = n3.animationValues || n3.latestValues), t3.root && t3.root.isUpdating && (t3.isLayoutDirty = true);
                const { crossfade: s2 } = t3.options;
                false === s2 && n3.hide();
              }
            }
            exitAnimationComplete() {
              this.members.forEach((t3) => {
                const { options: e3, resumingFrom: n3 } = t3;
                e3.onExitComplete && e3.onExitComplete(), n3 && n3.options.onExitComplete && n3.options.onExitComplete();
              });
            }
            scheduleRender() {
              this.members.forEach((t3) => {
                t3.instance && t3.scheduleRender(false);
              });
            }
            removeLeadSnapshot() {
              this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
            }
          }
          function Mi(t3, e3, n3) {
            let s2 = "";
            const i2 = t3.x.translate / e3.x, o2 = t3.y.translate / e3.y;
            if ((i2 || o2) && (s2 = `translate3d(${i2}px, ${o2}px, 0) `), 1 === e3.x && 1 === e3.y || (s2 += `scale(${1 / e3.x}, ${1 / e3.y}) `), n3) {
              const { rotate: t4, rotateX: e4, rotateY: i3 } = n3;
              t4 && (s2 += `rotate(${t4}deg) `), e4 && (s2 += `rotateX(${e4}deg) `), i3 && (s2 += `rotateY(${i3}deg) `);
            }
            const r2 = t3.x.scale * e3.x, a2 = t3.y.scale * e3.y;
            return 1 === r2 && 1 === a2 || (s2 += `scale(${r2}, ${a2})`), s2 || "none";
          }
          const Di = (t3, e3) => t3.depth - e3.depth;
          class ki {
            constructor() {
              this.children = [], this.isDirty = false;
            }
            add(t3) {
              h(this.children, t3), this.isDirty = true;
            }
            remove(t3) {
              d(this.children, t3), this.isDirty = true;
            }
            forEach(t3) {
              this.isDirty && this.children.sort(Di), this.isDirty = false, this.children.forEach(t3);
            }
          }
          const Ri = ["", "X", "Y", "Z"];
          let Li = 0;
          const ji = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 };
          function Bi({ attachResizeListener: t3, defaultParent: e3, measureScroll: n3, checkIsScrollRoot: s2, resetTransform: i2 }) {
            return class {
              constructor(t4 = {}, n4 = null == e3 ? void 0 : e3()) {
                this.id = Li++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = false, this.isAnimationBlocked = false, this.isLayoutDirty = false, this.isProjectionDirty = false, this.isSharedProjectionDirty = false, this.isTransformDirty = false, this.updateManuallyBlocked = false, this.updateBlockedByResize = false, this.isUpdating = false, this.isSVG = false, this.needsReset = false, this.shouldResetTransform = false, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = false, this.updateScheduled = false, this.checkUpdateFailed = () => {
                  this.isUpdating && (this.isUpdating = false, this.clearAllSnapshots());
                }, this.updateProjection = () => {
                  var t5;
                  ji.totalNodes = ji.resolvedTargetDeltas = ji.recalculatedProjection = 0, this.nodes.forEach(Ii), this.nodes.forEach(Yi), this.nodes.forEach(Xi), this.nodes.forEach(Ui), t5 = ji, window.MotionDebug && window.MotionDebug.record(t5);
                }, this.hasProjected = false, this.isVisible = true, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = t4, this.root = n4 ? n4.root || n4 : this, this.path = n4 ? [...n4.path, n4] : [], this.parent = n4, this.depth = n4 ? n4.depth + 1 : 0;
                for (let t5 = 0; t5 < this.path.length; t5++)
                  this.path[t5].shouldResetTransform = true;
                this.root === this && (this.nodes = new ki());
              }
              addEventListener(t4, e4) {
                return this.eventHandlers.has(t4) || this.eventHandlers.set(t4, new m()), this.eventHandlers.get(t4).add(e4);
              }
              notifyListeners(t4, ...e4) {
                const n4 = this.eventHandlers.get(t4);
                n4 && n4.notify(...e4);
              }
              hasListeners(t4) {
                return this.eventHandlers.has(t4);
              }
              mount(e4, n4 = this.root.hasTreeAnimated) {
                if (this.instance)
                  return;
                var s3;
                this.isSVG = (s3 = e4) instanceof SVGElement && "svg" !== s3.tagName, this.instance = e4;
                const { layoutId: i3, layout: o2, visualElement: r2 } = this.options;
                if (r2 && !r2.current && r2.mount(e4), this.root.nodes.add(this), this.parent && this.parent.children.add(this), n4 && (o2 || i3) && (this.isLayoutDirty = true), t3) {
                  let n5;
                  const s4 = () => this.root.updateBlockedByResize = false;
                  t3(e4, () => {
                    this.root.updateBlockedByResize = true, n5 && n5(), n5 = function(t4, e5) {
                      const n6 = performance.now(), s5 = ({ timestamp: e6 }) => {
                        const i4 = e6 - n6;
                        i4 >= 250 && (v(s5), t4(i4 - 250));
                      };
                      return y.read(s5, true), () => v(s5);
                    }(s4), ni.hasAnimatedSinceResize && (ni.hasAnimatedSinceResize = false, this.nodes.forEach(zi));
                  });
                }
                i3 && this.root.registerSharedNode(i3, this), false !== this.options.animate && r2 && (i3 || o2) && this.addEventListener("didUpdate", ({ delta: t4, hasLayoutChanged: e5, hasRelativeTargetChanged: n5, layout: s4 }) => {
                  if (this.isTreeAnimationBlocked())
                    return this.target = void 0, void (this.relativeTarget = void 0);
                  const i4 = this.options.transition || r2.getDefaultTransition() || Ji, { onLayoutAnimationStart: o3, onLayoutAnimationComplete: a2 } = r2.getProps(), l2 = !this.targetLayout || !Ai(this.targetLayout, s4) || n5, u2 = !e5 && n5;
                  if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || u2 || e5 && (l2 || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(t4, u2);
                    const e6 = { ...Re(i4, "layout"), onPlay: o3, onComplete: a2 };
                    (r2.shouldReduceMotion || this.options.layoutRoot) && (e6.delay = 0, e6.type = false), this.startAnimation(e6);
                  } else
                    e5 || zi(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                  this.targetLayout = s4;
                });
              }
              unmount() {
                this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
                const t4 = this.getStack();
                t4 && t4.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, v(this.updateProjection);
              }
              blockUpdate() {
                this.updateManuallyBlocked = true;
              }
              unblockUpdate() {
                this.updateManuallyBlocked = false;
              }
              isUpdateBlocked() {
                return this.updateManuallyBlocked || this.updateBlockedByResize;
              }
              isTreeAnimationBlocked() {
                return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
              }
              startUpdate() {
                this.isUpdateBlocked() || (this.isUpdating = true, this.nodes && this.nodes.forEach(Gi), this.animationId++);
              }
              getTransformTemplate() {
                const { visualElement: t4 } = this.options;
                return t4 && t4.getProps().transformTemplate;
              }
              willUpdate(t4 = true) {
                if (this.root.hasTreeAnimated = true, this.root.isUpdateBlocked())
                  return void (this.options.onExitComplete && this.options.onExitComplete());
                if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
                  return;
                this.isLayoutDirty = true;
                for (let t5 = 0; t5 < this.path.length; t5++) {
                  const e5 = this.path[t5];
                  e5.shouldResetTransform = true, e5.updateScroll("snapshot"), e5.options.layoutRoot && e5.willUpdate(false);
                }
                const { layoutId: e4, layout: n4 } = this.options;
                if (void 0 === e4 && !n4)
                  return;
                const s3 = this.getTransformTemplate();
                this.prevTransformTemplateValue = s3 ? s3(this.latestValues, "") : void 0, this.updateSnapshot(), t4 && this.notifyListeners("willUpdate");
              }
              update() {
                if (this.updateScheduled = false, this.isUpdateBlocked())
                  return this.unblockUpdate(), this.clearAllSnapshots(), void this.nodes.forEach($i);
                this.isUpdating || this.nodes.forEach(Wi), this.isUpdating = false, this.nodes.forEach(Hi), this.nodes.forEach(Fi), this.nodes.forEach(Oi), this.clearAllSnapshots();
                const t4 = performance.now();
                x.delta = R(0, 1e3 / 60, t4 - x.timestamp), x.timestamp = t4, x.isProcessing = true, P.update.process(x), P.preRender.process(x), P.render.process(x), x.isProcessing = false;
              }
              didUpdate() {
                this.updateScheduled || (this.updateScheduled = true, queueMicrotask(() => this.update()));
              }
              clearAllSnapshots() {
                this.nodes.forEach(Ni), this.sharedNodes.forEach(qi);
              }
              scheduleUpdateProjection() {
                y.preRender(this.updateProjection, false, true);
              }
              scheduleCheckAfterUnmount() {
                y.postRender(() => {
                  this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
                });
              }
              updateSnapshot() {
                !this.snapshot && this.instance && (this.snapshot = this.measure());
              }
              updateLayout() {
                if (!this.instance)
                  return;
                if (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead() || this.isLayoutDirty))
                  return;
                if (this.resumeFrom && !this.resumeFrom.instance)
                  for (let t5 = 0; t5 < this.path.length; t5++)
                    this.path[t5].updateScroll();
                const t4 = this.layout;
                this.layout = this.measure(false), this.layoutCorrected = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }, this.isLayoutDirty = false, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
                const { visualElement: e4 } = this.options;
                e4 && e4.notify("LayoutMeasure", this.layout.layoutBox, t4 ? t4.layoutBox : void 0);
              }
              updateScroll(t4 = "measure") {
                let e4 = Boolean(this.options.layoutScroll && this.instance);
                this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t4 && (e4 = false), e4 && (this.scroll = { animationId: this.root.animationId, phase: t4, isRoot: s2(this.instance), offset: n3(this.instance) });
              }
              resetTransform() {
                if (!i2)
                  return;
                const t4 = this.isLayoutDirty || this.shouldResetTransform, e4 = this.projectionDelta && !Ei(this.projectionDelta), n4 = this.getTransformTemplate(), s3 = n4 ? n4(this.latestValues, "") : void 0, o2 = s3 !== this.prevTransformTemplateValue;
                t4 && (e4 || Is(this.latestValues) || o2) && (i2(this.instance, s3), this.shouldResetTransform = false, this.scheduleRender());
              }
              measure(t4 = true) {
                const e4 = this.measurePageBox();
                let n4 = this.removeElementScroll(e4);
                var s3;
                return t4 && (n4 = this.removeTransform(n4)), eo((s3 = n4).x), eo(s3.y), { animationId: this.root.animationId, measuredBox: e4, layoutBox: n4, latestValues: {}, source: this.id };
              }
              measurePageBox() {
                const { visualElement: t4 } = this.options;
                if (!t4)
                  return { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
                const e4 = t4.measureViewportBox(), { scroll: n4 } = this.root;
                return n4 && (Xs(e4.x, n4.offset.x), Xs(e4.y, n4.offset.y)), e4;
              }
              removeElementScroll(t4) {
                const e4 = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
                vi(e4, t4);
                for (let n4 = 0; n4 < this.path.length; n4++) {
                  const s3 = this.path[n4], { scroll: i3, options: o2 } = s3;
                  if (s3 !== this.root && i3 && o2.layoutScroll) {
                    if (i3.isRoot) {
                      vi(e4, t4);
                      const { scroll: n5 } = this.root;
                      n5 && (Xs(e4.x, -n5.offset.x), Xs(e4.y, -n5.offset.y));
                    }
                    Xs(e4.x, i3.offset.x), Xs(e4.y, i3.offset.y);
                  }
                }
                return e4;
              }
              applyTransform(t4, e4 = false) {
                const n4 = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
                vi(n4, t4);
                for (let t5 = 0; t5 < this.path.length; t5++) {
                  const s3 = this.path[t5];
                  !e4 && s3.options.layoutScroll && s3.scroll && s3 !== s3.root && Ks(n4, { x: -s3.scroll.offset.x, y: -s3.scroll.offset.y }), Is(s3.latestValues) && Ks(n4, s3.latestValues);
                }
                return Is(this.latestValues) && Ks(n4, this.latestValues), n4;
              }
              removeTransform(t4) {
                const e4 = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
                vi(e4, t4);
                for (let t5 = 0; t5 < this.path.length; t5++) {
                  const n4 = this.path[t5];
                  if (!n4.instance)
                    continue;
                  if (!Is(n4.latestValues))
                    continue;
                  Os(n4.latestValues) && n4.updateSnapshot();
                  const s3 = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
                  vi(s3, n4.measurePageBox()), Si(e4, n4.latestValues, n4.snapshot ? n4.snapshot.layoutBox : void 0, s3);
                }
                return Is(this.latestValues) && Si(e4, this.latestValues), e4;
              }
              setTargetDelta(t4) {
                this.targetDelta = t4, this.root.scheduleUpdateProjection(), this.isProjectionDirty = true;
              }
              setOptions(t4) {
                this.options = { ...this.options, ...t4, crossfade: void 0 === t4.crossfade || t4.crossfade };
              }
              clearMeasurements() {
                this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = false;
              }
              forceRelativeParentToResolveTarget() {
                this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== x.timestamp && this.relativeParent.resolveTargetDelta(true);
              }
              resolveTargetDelta(t4 = false) {
                var e4;
                const n4 = this.getLead();
                this.isProjectionDirty || (this.isProjectionDirty = n4.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = n4.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = n4.isSharedProjectionDirty);
                const s3 = Boolean(this.resumingFrom) || this !== n4;
                if (!(t4 || s3 && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (e4 = this.parent) || void 0 === e4 ? void 0 : e4.isProjectionDirty) || this.attemptToResolveRelativeTarget))
                  return;
                const { layout: i3, layoutId: o2 } = this.options;
                if (this.layout && (i3 || o2)) {
                  if (this.resolvedRelativeTargetAt = x.timestamp, !this.targetDelta && !this.relativeTarget) {
                    const t5 = this.getClosestProjectingParent();
                    t5 && t5.layout && 1 !== this.animationProgress ? (this.relativeParent = t5, this.forceRelativeParentToResolveTarget(), this.relativeTarget = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }, this.relativeTargetOrigin = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }, Cs(this.relativeTargetOrigin, this.layout.layoutBox, t5.layout.layoutBox), vi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
                  }
                  if (this.relativeTarget || this.targetDelta) {
                    var r2, a2, l2;
                    if (this.target || (this.target = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }, this.targetWithTransforms = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), r2 = this.target, a2 = this.relativeTarget, l2 = this.relativeParent.target, As(r2.x, a2.x, l2.x), As(r2.y, a2.y, l2.y)) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : vi(this.target, this.layout.layoutBox), zs(this.target, this.targetDelta)) : vi(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                      this.attemptToResolveRelativeTarget = false;
                      const t5 = this.getClosestProjectingParent();
                      t5 && Boolean(t5.resumingFrom) === Boolean(this.resumingFrom) && !t5.options.layoutScroll && t5.target && 1 !== this.animationProgress ? (this.relativeParent = t5, this.forceRelativeParentToResolveTarget(), this.relativeTarget = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }, this.relativeTargetOrigin = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }, Cs(this.relativeTargetOrigin, this.target, t5.target), vi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
                    }
                    ji.resolvedTargetDeltas++;
                  }
                }
              }
              getClosestProjectingParent() {
                if (this.parent && !Os(this.parent.latestValues) && !Us(this.parent.latestValues))
                  return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
              }
              isProjecting() {
                return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
              }
              calcProjection() {
                var t4;
                const e4 = this.getLead(), n4 = Boolean(this.resumingFrom) || this !== e4;
                let s3 = true;
                if ((this.isProjectionDirty || (null === (t4 = this.parent) || void 0 === t4 ? void 0 : t4.isProjectionDirty)) && (s3 = false), n4 && (this.isSharedProjectionDirty || this.isTransformDirty) && (s3 = false), this.resolvedRelativeTargetAt === x.timestamp && (s3 = false), s3)
                  return;
                const { layout: i3, layoutId: o2 } = this.options;
                if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !i3 && !o2)
                  return;
                vi(this.layoutCorrected, this.layout.layoutBox);
                const r2 = this.treeScale.x, a2 = this.treeScale.y;
                !function(t5, e5, n5, s4 = false) {
                  const i4 = n5.length;
                  if (!i4)
                    return;
                  let o3, r3;
                  e5.x = e5.y = 1;
                  for (let a3 = 0; a3 < i4; a3++) {
                    o3 = n5[a3], r3 = o3.projectionDelta;
                    const i5 = o3.instance;
                    i5 && i5.style && "contents" === i5.style.display || (s4 && o3.options.layoutScroll && o3.scroll && o3 !== o3.root && Ks(t5, { x: -o3.scroll.offset.x, y: -o3.scroll.offset.y }), r3 && (e5.x *= r3.x.scale, e5.y *= r3.y.scale, zs(t5, r3)), s4 && Is(o3.latestValues) && Ks(t5, o3.latestValues));
                  }
                  e5.x = Ys(e5.x), e5.y = Ys(e5.y);
                }(this.layoutCorrected, this.treeScale, this.path, n4), !e4.layout || e4.target || 1 === this.treeScale.x && 1 === this.treeScale.y || (e4.target = e4.layout.layoutBox);
                const { target: l2 } = e4;
                if (!l2)
                  return void (this.projectionTransform && (this.projectionDelta = { x: { translate: 0, scale: 1, origin: 0, originPoint: 0 }, y: { translate: 0, scale: 1, origin: 0, originPoint: 0 } }, this.projectionTransform = "none", this.scheduleRender()));
                this.projectionDelta || (this.projectionDelta = { x: { translate: 0, scale: 1, origin: 0, originPoint: 0 }, y: { translate: 0, scale: 1, origin: 0, originPoint: 0 } }, this.projectionDeltaWithTransform = { x: { translate: 0, scale: 1, origin: 0, originPoint: 0 }, y: { translate: 0, scale: 1, origin: 0, originPoint: 0 } });
                const u2 = this.projectionTransform;
                Es(this.projectionDelta, this.layoutCorrected, l2, this.latestValues), this.projectionTransform = Mi(this.projectionDelta, this.treeScale), this.projectionTransform === u2 && this.treeScale.x === r2 && this.treeScale.y === a2 || (this.hasProjected = true, this.scheduleRender(), this.notifyListeners("projectionUpdate", l2)), ji.recalculatedProjection++;
              }
              hide() {
                this.isVisible = false;
              }
              show() {
                this.isVisible = true;
              }
              scheduleRender(t4 = true) {
                if (this.options.scheduleRender && this.options.scheduleRender(), t4) {
                  const t5 = this.getStack();
                  t5 && t5.scheduleRender();
                }
                this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
              }
              setAnimationOrigin(t4, e4 = false) {
                const n4 = this.snapshot, s3 = n4 ? n4.latestValues : {}, i3 = { ...this.latestValues }, o2 = { x: { translate: 0, scale: 1, origin: 0, originPoint: 0 }, y: { translate: 0, scale: 1, origin: 0, originPoint: 0 } };
                this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !e4;
                const r2 = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }, a2 = (n4 ? n4.source : void 0) !== (this.layout ? this.layout.source : void 0), l2 = this.getStack(), u2 = !l2 || l2.members.length <= 1, c2 = Boolean(a2 && !u2 && true === this.options.crossfade && !this.path.some(_i));
                let h2;
                this.animationProgress = 0, this.mixTargetDelta = (e5) => {
                  const n5 = e5 / 1e3;
                  var l3, d2, m2, p2, f2, g2;
                  Zi(o2.x, t4.x, n5), Zi(o2.y, t4.y, n5), this.setTargetDelta(o2), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Cs(r2, this.layout.layoutBox, this.relativeParent.layout.layoutBox), m2 = this.relativeTarget, p2 = this.relativeTargetOrigin, f2 = r2, g2 = n5, Ki(m2.x, p2.x, f2.x, g2), Ki(m2.y, p2.y, f2.y, g2), h2 && (l3 = this.relativeTarget, d2 = h2, l3.x.min === d2.x.min && l3.x.max === d2.x.max && l3.y.min === d2.y.min && l3.y.max === d2.y.max) && (this.isProjectionDirty = false), h2 || (h2 = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }), vi(h2, this.relativeTarget)), a2 && (this.animationValues = i3, function(t5, e6, n6, s4, i4, o3) {
                    i4 ? (t5.opacity = Kt(0, void 0 !== n6.opacity ? n6.opacity : 1, pi(s4)), t5.opacityExit = Kt(void 0 !== e6.opacity ? e6.opacity : 1, 0, fi(s4))) : o3 && (t5.opacity = Kt(void 0 !== e6.opacity ? e6.opacity : 1, void 0 !== n6.opacity ? n6.opacity : 1, s4));
                    for (let i5 = 0; i5 < ci; i5++) {
                      const o4 = `border${ui[i5]}Radius`;
                      let r3 = mi(e6, o4), a3 = mi(n6, o4);
                      void 0 === r3 && void 0 === a3 || (r3 || (r3 = 0), a3 || (a3 = 0), 0 === r3 || 0 === a3 || di(r3) === di(a3) ? (t5[o4] = Math.max(Kt(hi(r3), hi(a3), s4), 0), (H.test(a3) || H.test(r3)) && (t5[o4] += "%")) : t5[o4] = a3);
                    }
                    (e6.rotate || n6.rotate) && (t5.rotate = Kt(e6.rotate || 0, n6.rotate || 0, s4));
                  }(i3, s3, this.latestValues, n5, c2, u2)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = n5;
                }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
              }
              startAnimation(t4) {
                this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (v(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = y.update(() => {
                  ni.hasAnimatedSinceResize = true, this.currentAnimation = function(t5, e4, n4) {
                    const s3 = je(0) ? 0 : S(0);
                    return s3.start(Le("", s3, 1e3, n4)), s3.animation;
                  }(0, 0, { ...t4, onUpdate: (e4) => {
                    this.mixTargetDelta(e4), t4.onUpdate && t4.onUpdate(e4);
                  }, onComplete: () => {
                    t4.onComplete && t4.onComplete(), this.completeAnimation();
                  } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
                });
              }
              completeAnimation() {
                this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
                const t4 = this.getStack();
                t4 && t4.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
              }
              finishAnimation() {
                this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3), this.currentAnimation.stop()), this.completeAnimation();
              }
              applyTransformsToTarget() {
                const t4 = this.getLead();
                let { targetWithTransforms: e4, target: n4, layout: s3, latestValues: i3 } = t4;
                if (e4 && n4 && s3) {
                  if (this !== t4 && this.layout && s3 && no(this.options.animationType, this.layout.layoutBox, s3.layoutBox)) {
                    n4 = this.target || { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
                    const e5 = Ts(this.layout.layoutBox.x);
                    n4.x.min = t4.target.x.min, n4.x.max = n4.x.min + e5;
                    const s4 = Ts(this.layout.layoutBox.y);
                    n4.y.min = t4.target.y.min, n4.y.max = n4.y.min + s4;
                  }
                  vi(e4, n4), Ks(e4, i3), Es(this.projectionDeltaWithTransform, this.layoutCorrected, e4, i3);
                }
              }
              registerSharedNode(t4, e4) {
                this.sharedNodes.has(t4) || this.sharedNodes.set(t4, new Ci()), this.sharedNodes.get(t4).add(e4);
                const n4 = e4.options.initialPromotionConfig;
                e4.promote({ transition: n4 ? n4.transition : void 0, preserveFollowOpacity: n4 && n4.shouldPreserveFollowOpacity ? n4.shouldPreserveFollowOpacity(e4) : void 0 });
              }
              isLead() {
                const t4 = this.getStack();
                return !t4 || t4.lead === this;
              }
              getLead() {
                var t4;
                const { layoutId: e4 } = this.options;
                return e4 && (null === (t4 = this.getStack()) || void 0 === t4 ? void 0 : t4.lead) || this;
              }
              getPrevLead() {
                var t4;
                const { layoutId: e4 } = this.options;
                return e4 ? null === (t4 = this.getStack()) || void 0 === t4 ? void 0 : t4.prevLead : void 0;
              }
              getStack() {
                const { layoutId: t4 } = this.options;
                if (t4)
                  return this.root.sharedNodes.get(t4);
              }
              promote({ needsReset: t4, transition: e4, preserveFollowOpacity: n4 } = {}) {
                const s3 = this.getStack();
                s3 && s3.promote(this, n4), t4 && (this.projectionDelta = void 0, this.needsReset = true), e4 && this.setOptions({ transition: e4 });
              }
              relegate() {
                const t4 = this.getStack();
                return !!t4 && t4.relegate(this);
              }
              resetRotation() {
                const { visualElement: t4 } = this.options;
                if (!t4)
                  return;
                let e4 = false;
                const { latestValues: n4 } = t4;
                if ((n4.rotate || n4.rotateX || n4.rotateY || n4.rotateZ) && (e4 = true), !e4)
                  return;
                const s3 = {};
                for (let e5 = 0; e5 < Ri.length; e5++) {
                  const i3 = "rotate" + Ri[e5];
                  n4[i3] && (s3[i3] = n4[i3], t4.setStaticValue(i3, 0));
                }
                t4.render();
                for (const e5 in s3)
                  t4.setStaticValue(e5, s3[e5]);
                t4.scheduleRender();
              }
              getProjectionStyles(t4 = {}) {
                var e4, n4;
                const s3 = {};
                if (!this.instance || this.isSVG)
                  return s3;
                if (!this.isVisible)
                  return { visibility: "hidden" };
                s3.visibility = "";
                const i3 = this.getTransformTemplate();
                if (this.needsReset)
                  return this.needsReset = false, s3.opacity = "", s3.pointerEvents = In(t4.pointerEvents) || "", s3.transform = i3 ? i3(this.latestValues, "") : "none", s3;
                const o2 = this.getLead();
                if (!this.projectionDelta || !this.layout || !o2.target) {
                  const e5 = {};
                  return this.options.layoutId && (e5.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, e5.pointerEvents = In(t4.pointerEvents) || ""), this.hasProjected && !Is(this.latestValues) && (e5.transform = i3 ? i3({}, "") : "none", this.hasProjected = false), e5;
                }
                const r2 = o2.animationValues || o2.latestValues;
                this.applyTransformsToTarget(), s3.transform = Mi(this.projectionDeltaWithTransform, this.treeScale, r2), i3 && (s3.transform = i3(r2, s3.transform));
                const { x: a2, y: l2 } = this.projectionDelta;
                s3.transformOrigin = `${100 * a2.origin}% ${100 * l2.origin}% 0`, o2.animationValues ? s3.opacity = o2 === this ? null !== (n4 = null !== (e4 = r2.opacity) && void 0 !== e4 ? e4 : this.latestValues.opacity) && void 0 !== n4 ? n4 : 1 : this.preserveOpacity ? this.latestValues.opacity : r2.opacityExit : s3.opacity = o2 === this ? void 0 !== r2.opacity ? r2.opacity : "" : void 0 !== r2.opacityExit ? r2.opacityExit : 0;
                for (const t5 in pn) {
                  if (void 0 === r2[t5])
                    continue;
                  const { correct: e5, applyTo: n5 } = pn[t5], i4 = "none" === s3.transform ? r2[t5] : e5(r2[t5], o2);
                  if (n5) {
                    const t6 = n5.length;
                    for (let e6 = 0; e6 < t6; e6++)
                      s3[n5[e6]] = i4;
                  } else
                    s3[t5] = i4;
                }
                return this.options.layoutId && (s3.pointerEvents = o2 === this ? In(t4.pointerEvents) || "" : "none"), s3;
              }
              clearSnapshot() {
                this.resumeFrom = this.snapshot = void 0;
              }
              resetTree() {
                this.root.nodes.forEach((t4) => {
                  var e4;
                  return null === (e4 = t4.currentAnimation) || void 0 === e4 ? void 0 : e4.stop();
                }), this.root.nodes.forEach($i), this.root.sharedNodes.clear();
              }
            };
          }
          function Fi(t3) {
            t3.updateLayout();
          }
          function Oi(t3) {
            var e3;
            const n3 = (null === (e3 = t3.resumeFrom) || void 0 === e3 ? void 0 : e3.snapshot) || t3.snapshot;
            if (t3.isLead() && t3.layout && n3 && t3.hasListeners("didUpdate")) {
              const { layoutBox: e4, measuredBox: s2 } = t3.layout, { animationType: i2 } = t3.options, o2 = n3.source !== t3.layout.source;
              "size" === i2 ? js((t4) => {
                const s3 = o2 ? n3.measuredBox[t4] : n3.layoutBox[t4], i3 = Ts(s3);
                s3.min = e4[t4].min, s3.max = s3.min + i3;
              }) : no(i2, n3.layoutBox, e4) && js((s3) => {
                const i3 = o2 ? n3.measuredBox[s3] : n3.layoutBox[s3], r3 = Ts(e4[s3]);
                i3.max = i3.min + r3, t3.relativeTarget && !t3.currentAnimation && (t3.isProjectionDirty = true, t3.relativeTarget[s3].max = t3.relativeTarget[s3].min + r3);
              });
              const r2 = { x: { translate: 0, scale: 1, origin: 0, originPoint: 0 }, y: { translate: 0, scale: 1, origin: 0, originPoint: 0 } };
              Es(r2, e4, n3.layoutBox);
              const a2 = { x: { translate: 0, scale: 1, origin: 0, originPoint: 0 }, y: { translate: 0, scale: 1, origin: 0, originPoint: 0 } };
              o2 ? Es(a2, t3.applyTransform(s2, true), n3.measuredBox) : Es(a2, e4, n3.layoutBox);
              const l2 = !Ei(r2);
              let u2 = false;
              if (!t3.resumeFrom) {
                const s3 = t3.getClosestProjectingParent();
                if (s3 && !s3.resumeFrom) {
                  const { snapshot: i3, layout: o3 } = s3;
                  if (i3 && o3) {
                    const r3 = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
                    Cs(r3, n3.layoutBox, i3.layoutBox);
                    const a3 = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
                    Cs(a3, e4, o3.layoutBox), Ai(r3, a3) || (u2 = true), s3.options.layoutRoot && (t3.relativeTarget = a3, t3.relativeTargetOrigin = r3, t3.relativeParent = s3);
                  }
                }
              }
              t3.notifyListeners("didUpdate", { layout: e4, snapshot: n3, delta: a2, layoutDelta: r2, hasLayoutChanged: l2, hasRelativeTargetChanged: u2 });
            } else if (t3.isLead()) {
              const { onExitComplete: e4 } = t3.options;
              e4 && e4();
            }
            t3.options.transition = void 0;
          }
          function Ii(t3) {
            ji.totalNodes++, t3.parent && (t3.isProjecting() || (t3.isProjectionDirty = t3.parent.isProjectionDirty), t3.isSharedProjectionDirty || (t3.isSharedProjectionDirty = Boolean(t3.isProjectionDirty || t3.parent.isProjectionDirty || t3.parent.isSharedProjectionDirty)), t3.isTransformDirty || (t3.isTransformDirty = t3.parent.isTransformDirty));
          }
          function Ui(t3) {
            t3.isProjectionDirty = t3.isSharedProjectionDirty = t3.isTransformDirty = false;
          }
          function Ni(t3) {
            t3.clearSnapshot();
          }
          function $i(t3) {
            t3.clearMeasurements();
          }
          function Wi(t3) {
            t3.isLayoutDirty = false;
          }
          function Hi(t3) {
            const { visualElement: e3 } = t3.options;
            e3 && e3.getProps().onBeforeLayoutMeasure && e3.notify("BeforeLayoutMeasure"), t3.resetTransform();
          }
          function zi(t3) {
            t3.finishAnimation(), t3.targetDelta = t3.relativeTarget = t3.target = void 0, t3.isProjectionDirty = true;
          }
          function Yi(t3) {
            t3.resolveTargetDelta();
          }
          function Xi(t3) {
            t3.calcProjection();
          }
          function Gi(t3) {
            t3.resetRotation();
          }
          function qi(t3) {
            t3.removeLeadSnapshot();
          }
          function Zi(t3, e3, n3) {
            t3.translate = Kt(e3.translate, 0, n3), t3.scale = Kt(e3.scale, 1, n3), t3.origin = e3.origin, t3.originPoint = e3.originPoint;
          }
          function Ki(t3, e3, n3, s2) {
            t3.min = Kt(e3.min, n3.min, s2), t3.max = Kt(e3.max, n3.max, s2);
          }
          function _i(t3) {
            return t3.animationValues && void 0 !== t3.animationValues.opacityExit;
          }
          const Ji = { duration: 0.45, ease: [0.4, 0, 0.1, 1] }, Qi = (t3) => "undefined" != typeof navigator && navigator.userAgent.toLowerCase().includes(t3), to = Qi("applewebkit/") && !Qi("chrome/") ? Math.round : n2;
          function eo(t3) {
            t3.min = to(t3.min), t3.max = to(t3.max);
          }
          function no(t3, e3, n3) {
            return "position" === t3 || "preserve-aspect" === t3 && !Ss(Vi(e3), Vi(n3), 0.2);
          }
          const so = Bi({ attachResizeListener: (t3, e3) => Hn(t3, "resize", e3), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => true }), io = { current: void 0 }, oo = Bi({ measureScroll: (t3) => ({ x: t3.scrollLeft, y: t3.scrollTop }), defaultParent: () => {
            if (!io.current) {
              const t3 = new so({});
              t3.mount(window), t3.setOptions({ layoutScroll: true }), io.current = t3;
            }
            return io.current;
          }, resetTransform: (t3, e3) => {
            t3.style.transform = void 0 !== e3 ? e3 : "none";
          }, checkIsScrollRoot: (t3) => Boolean("fixed" === window.getComputedStyle(t3).position) }), ro = { pan: { Feature: class extends Jn {
            constructor() {
              super(...arguments), this.removePointerDownListener = n2;
            }
            onPointerDown(t3) {
              this.session = new fs(t3, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() });
            }
            createPanHandlers() {
              const { onPanSessionStart: t3, onPanStart: e3, onPan: n3, onPanEnd: s2 } = this.node.getProps();
              return { onSessionStart: ei(t3), onStart: ei(e3), onMove: n3, onEnd: (t4, e4) => {
                delete this.session, s2 && y.update(() => s2(t4, e4));
              } };
            }
            mount() {
              this.removePointerDownListener = Xn(this.node.current, "pointerdown", (t3) => this.onPointerDown(t3));
            }
            update() {
              this.session && this.session.updateHandlers(this.createPanHandlers());
            }
            unmount() {
              this.removePointerDownListener(), this.session && this.session.end();
            }
          } }, drag: { Feature: class extends Jn {
            constructor(t3) {
              super(t3), this.removeGroupControls = n2, this.removeListeners = n2, this.controls = new Qs(t3);
            }
            mount() {
              const { dragControls: t3 } = this.node.getProps();
              t3 && (this.removeGroupControls = t3.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || n2;
            }
            unmount() {
              this.removeGroupControls(), this.removeListeners();
            }
          }, ProjectionNode: oo, MeasureLayout: ai } }, ao = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
          function lo(t3, e3, n3 = 1) {
            r(n3 <= 4, `Max CSS variable fallback depth detected in property "${t3}". This may indicate a circular fallback dependency.`);
            const [s2, i2] = function(t4) {
              const e4 = ao.exec(t4);
              if (!e4)
                return [,];
              const [, n4, s3] = e4;
              return [n4, s3];
            }(t3);
            if (!s2)
              return;
            const o2 = window.getComputedStyle(e3).getPropertyValue(s2);
            if (o2) {
              const t4 = o2.trim();
              return l(t4) ? parseFloat(t4) : t4;
            }
            return A(i2) ? lo(i2, e3, n3 + 1) : i2;
          }
          const uo = /* @__PURE__ */ new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), co = (t3) => uo.has(t3), ho = (t3) => t3 === L || t3 === z, mo = (t3, e3) => parseFloat(t3.split(", ")[e3]), po = (t3, e3) => (n3, { transform: s2 }) => {
            if ("none" === s2 || !s2)
              return 0;
            const i2 = s2.match(/^matrix3d\((.+)\)$/);
            if (i2)
              return mo(i2[1], e3);
            {
              const e4 = s2.match(/^matrix\((.+)\)$/);
              return e4 ? mo(e4[1], t3) : 0;
            }
          }, fo = /* @__PURE__ */ new Set(["x", "y", "z"]), go = wt.filter((t3) => !fo.has(t3)), yo = { width: ({ x: t3 }, { paddingLeft: e3 = "0", paddingRight: n3 = "0" }) => t3.max - t3.min - parseFloat(e3) - parseFloat(n3), height: ({ y: t3 }, { paddingTop: e3 = "0", paddingBottom: n3 = "0" }) => t3.max - t3.min - parseFloat(e3) - parseFloat(n3), top: (t3, { top: e3 }) => parseFloat(e3), left: (t3, { left: e3 }) => parseFloat(e3), bottom: ({ y: t3 }, { top: e3 }) => parseFloat(e3) + (t3.max - t3.min), right: ({ x: t3 }, { left: e3 }) => parseFloat(e3) + (t3.max - t3.min), x: po(4, 13), y: po(5, 14) };
          yo.translateX = yo.x, yo.translateY = yo.y;
          function vo(t3, e3, n3, s2) {
            return ((t4) => Object.keys(t4).some(co))(e3) ? ((t4, e4, n4 = {}, s3 = {}) => {
              e4 = { ...e4 }, s3 = { ...s3 };
              const i2 = Object.keys(e4).filter(co);
              let o2 = [], a2 = false;
              const l2 = [];
              if (i2.forEach((i3) => {
                const u2 = t4.getValue(i3);
                if (!t4.hasValue(i3))
                  return;
                let h2 = n4[i3], d2 = gt(h2);
                const m2 = e4[i3];
                let p2;
                if (c(m2)) {
                  const t5 = m2.length, e5 = null === m2[0] ? 1 : 0;
                  h2 = m2[e5], d2 = gt(h2);
                  for (let n5 = e5; n5 < t5 && null !== m2[n5]; n5++)
                    p2 ? r(gt(m2[n5]) === p2, "All keyframes must be of the same type") : (p2 = gt(m2[n5]), r(p2 === d2 || ho(d2) && ho(p2), "Keyframes must be of the same dimension as the current value"));
                } else
                  p2 = gt(m2);
                if (d2 !== p2)
                  if (ho(d2) && ho(p2)) {
                    const t5 = u2.get();
                    "string" == typeof t5 && u2.set(parseFloat(t5)), "string" == typeof m2 ? e4[i3] = parseFloat(m2) : Array.isArray(m2) && p2 === z && (e4[i3] = m2.map(parseFloat));
                  } else
                    (null == d2 ? void 0 : d2.transform) && (null == p2 ? void 0 : p2.transform) && (0 === h2 || 0 === m2) ? 0 === h2 ? u2.set(p2.transform(h2)) : e4[i3] = d2.transform(m2) : (a2 || (o2 = function(t5) {
                      const e5 = [];
                      return go.forEach((n5) => {
                        const s4 = t5.getValue(n5);
                        void 0 !== s4 && (e5.push([n5, s4.get()]), s4.set(n5.startsWith("scale") ? 1 : 0));
                      }), e5.length && t5.render(), e5;
                    }(t4), a2 = true), l2.push(i3), s3[i3] = void 0 !== s3[i3] ? s3[i3] : e4[i3], u2.jump(m2));
              }), l2.length) {
                const n5 = l2.indexOf("height") >= 0 ? window.pageYOffset : null, i3 = ((t5, e5, n6) => {
                  const s4 = e5.measureViewportBox(), i4 = e5.current, o3 = getComputedStyle(i4), { display: r2 } = o3, a3 = {};
                  "none" === r2 && e5.setStaticValue("display", t5.display || "block"), n6.forEach((t6) => {
                    a3[t6] = yo[t6](s4, o3);
                  }), e5.render();
                  const l3 = e5.measureViewportBox();
                  return n6.forEach((n7) => {
                    const s5 = e5.getValue(n7);
                    s5 && s5.jump(a3[n7]), t5[n7] = yo[n7](l3, o3);
                  }), t5;
                })(e4, t4, l2);
                return o2.length && o2.forEach(([e5, n6]) => {
                  t4.getValue(e5).set(n6);
                }), t4.render(), He && null !== n5 && window.scrollTo({ top: n5 }), { target: i3, transitionEnd: s3 };
              }
              return { target: e4, transitionEnd: s3 };
            })(t3, e3, n3, s2) : { target: e3, transitionEnd: s2 };
          }
          const xo = { current: null }, Po = { current: false }, bo = /* @__PURE__ */ new WeakMap(), To = Object.keys(on), So = To.length, wo = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], Eo = Qe.length;
          class Ao extends class {
            constructor({ parent: t3, props: e3, presenceContext: n3, reducedMotionConfig: s2, visualState: i2 }, o2 = {}) {
              this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = false, this.isControllingVariants = false, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
                this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
              }, this.scheduleRender = () => y.render(this.render, false, true);
              const { latestValues: r2, renderState: a2 } = i2;
              this.latestValues = r2, this.baseTarget = { ...r2 }, this.initialValues = e3.initial ? { ...r2 } : {}, this.renderState = a2, this.parent = t3, this.props = e3, this.presenceContext = n3, this.depth = t3 ? t3.depth + 1 : 0, this.reducedMotionConfig = s2, this.options = o2, this.isControllingVariants = tn(e3), this.isVariantNode = en(e3), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = Boolean(t3 && t3.current);
              const { willChange: l2, ...u2 } = this.scrapeMotionValuesFromProps(e3, {});
              for (const t4 in u2) {
                const e4 = u2[t4];
                void 0 !== r2[t4] && je(e4) && (e4.set(r2[t4], false), Be(l2) && l2.add(t4));
              }
            }
            scrapeMotionValuesFromProps(t3, e3) {
              return {};
            }
            mount(t3) {
              this.current = t3, bo.set(t3, this), this.projection && !this.projection.instance && this.projection.mount(t3), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t4, e3) => this.bindToMotionValue(e3, t4)), Po.current || function() {
                if (Po.current = true, He)
                  if (window.matchMedia) {
                    const t4 = window.matchMedia("(prefers-reduced-motion)"), e3 = () => xo.current = t4.matches;
                    t4.addListener(e3), e3();
                  } else
                    xo.current = false;
              }(), this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || xo.current), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
            }
            unmount() {
              bo.delete(this.current), this.projection && this.projection.unmount(), v(this.notifyUpdate), v(this.render), this.valueSubscriptions.forEach((t3) => t3()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
              for (const t3 in this.events)
                this.events[t3].clear();
              for (const t3 in this.features)
                this.features[t3].unmount();
              this.current = null;
            }
            bindToMotionValue(t3, e3) {
              const n3 = Et.has(t3), s2 = e3.on("change", (e4) => {
                this.latestValues[t3] = e4, this.props.onUpdate && y.update(this.notifyUpdate, false, true), n3 && this.projection && (this.projection.isTransformDirty = true);
              }), i2 = e3.on("renderRequest", this.scheduleRender);
              this.valueSubscriptions.set(t3, () => {
                s2(), i2();
              });
            }
            sortNodePosition(t3) {
              return this.current && this.sortInstanceNodePosition && this.type === t3.type ? this.sortInstanceNodePosition(this.current, t3.current) : 0;
            }
            loadFeatures({ children: t3, ...e3 }, n3, s2, i2) {
              let o2, r2;
              for (let t4 = 0; t4 < So; t4++) {
                const n4 = To[t4], { isEnabled: s3, Feature: i3, ProjectionNode: a2, MeasureLayout: l2 } = on[n4];
                a2 && (o2 = a2), s3(e3) && (!this.features[n4] && i3 && (this.features[n4] = new i3(this)), l2 && (r2 = l2));
              }
              if (!this.projection && o2) {
                this.projection = new o2(this.latestValues, this.parent && this.parent.projection);
                const { layoutId: t4, layout: n4, drag: s3, dragConstraints: r3, layoutScroll: a2, layoutRoot: l2 } = e3;
                this.projection.setOptions({ layoutId: t4, layout: n4, alwaysMeasureLayout: Boolean(s3) || r3 && Ze(r3), visualElement: this, scheduleRender: () => this.scheduleRender(), animationType: "string" == typeof n4 ? n4 : "both", initialPromotionConfig: i2, layoutScroll: a2, layoutRoot: l2 });
              }
              return r2;
            }
            updateFeatures() {
              for (const t3 in this.features) {
                const e3 = this.features[t3];
                e3.isMounted ? e3.update() : (e3.mount(), e3.isMounted = true);
              }
            }
            triggerBuild() {
              this.build(this.renderState, this.latestValues, this.options, this.props);
            }
            measureViewportBox() {
              return this.current ? this.measureInstanceViewportBox(this.current, this.props) : { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
            }
            getStaticValue(t3) {
              return this.latestValues[t3];
            }
            setStaticValue(t3, e3) {
              this.latestValues[t3] = e3;
            }
            makeTargetAnimatable(t3, e3 = true) {
              return this.makeTargetAnimatableFromInstance(t3, this.props, e3);
            }
            update(t3, e3) {
              (t3.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t3, this.prevPresenceContext = this.presenceContext, this.presenceContext = e3;
              for (let e4 = 0; e4 < wo.length; e4++) {
                const n3 = wo[e4];
                this.propEventSubscriptions[n3] && (this.propEventSubscriptions[n3](), delete this.propEventSubscriptions[n3]);
                const s2 = t3["on" + n3];
                s2 && (this.propEventSubscriptions[n3] = this.on(n3, s2));
              }
              this.prevMotionValues = function(t4, e4, n3) {
                const { willChange: s2 } = e4;
                for (const i2 in e4) {
                  const o2 = e4[i2], r2 = n3[i2];
                  if (je(o2))
                    t4.addValue(i2, o2), Be(s2) && s2.add(i2);
                  else if (je(r2))
                    t4.addValue(i2, S(o2, { owner: t4 })), Be(s2) && s2.remove(i2);
                  else if (r2 !== o2)
                    if (t4.hasValue(i2)) {
                      const e5 = t4.getValue(i2);
                      !e5.hasAnimated && e5.set(o2);
                    } else {
                      const e5 = t4.getStaticValue(i2);
                      t4.addValue(i2, S(void 0 !== e5 ? e5 : o2, { owner: t4 }));
                    }
                }
                for (const s3 in n3)
                  void 0 === e4[s3] && t4.removeValue(s3);
                return e4;
              }(this, this.scrapeMotionValuesFromProps(t3, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
            }
            getProps() {
              return this.props;
            }
            getVariant(t3) {
              return this.props.variants ? this.props.variants[t3] : void 0;
            }
            getDefaultTransition() {
              return this.props.transition;
            }
            getTransformPagePoint() {
              return this.props.transformPagePoint;
            }
            getClosestVariantNode() {
              return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
            }
            getVariantContext(t3 = false) {
              if (t3)
                return this.parent ? this.parent.getVariantContext() : void 0;
              if (!this.isControllingVariants) {
                const t4 = this.parent && this.parent.getVariantContext() || {};
                return void 0 !== this.props.initial && (t4.initial = this.props.initial), t4;
              }
              const e3 = {};
              for (let t4 = 0; t4 < Eo; t4++) {
                const n3 = Qe[t4], s2 = this.props[n3];
                (Ke(s2) || false === s2) && (e3[n3] = s2);
              }
              return e3;
            }
            addVariantChild(t3) {
              const e3 = this.getClosestVariantNode();
              if (e3)
                return e3.variantChildren && e3.variantChildren.add(t3), () => e3.variantChildren.delete(t3);
            }
            addValue(t3, e3) {
              e3 !== this.values.get(t3) && (this.removeValue(t3), this.bindToMotionValue(t3, e3)), this.values.set(t3, e3), this.latestValues[t3] = e3.get();
            }
            removeValue(t3) {
              this.values.delete(t3);
              const e3 = this.valueSubscriptions.get(t3);
              e3 && (e3(), this.valueSubscriptions.delete(t3)), delete this.latestValues[t3], this.removeValueFromRenderState(t3, this.renderState);
            }
            hasValue(t3) {
              return this.values.has(t3);
            }
            getValue(t3, e3) {
              if (this.props.values && this.props.values[t3])
                return this.props.values[t3];
              let n3 = this.values.get(t3);
              return void 0 === n3 && void 0 !== e3 && (n3 = S(e3, { owner: this }), this.addValue(t3, n3)), n3;
            }
            readValue(t3) {
              var e3;
              return void 0 === this.latestValues[t3] && this.current ? null !== (e3 = this.getBaseTargetFromProps(this.props, t3)) && void 0 !== e3 ? e3 : this.readValueFromInstance(this.current, t3, this.options) : this.latestValues[t3];
            }
            setBaseTarget(t3, e3) {
              this.baseTarget[t3] = e3;
            }
            getBaseTarget(t3) {
              var e3;
              const { initial: n3 } = this.props, s2 = "string" == typeof n3 || "object" == typeof n3 ? null === (e3 = vt(this.props, n3)) || void 0 === e3 ? void 0 : e3[t3] : void 0;
              if (n3 && void 0 !== s2)
                return s2;
              const i2 = this.getBaseTargetFromProps(this.props, t3);
              return void 0 === i2 || je(i2) ? void 0 !== this.initialValues[t3] && void 0 === s2 ? void 0 : this.baseTarget[t3] : i2;
            }
            on(t3, e3) {
              return this.events[t3] || (this.events[t3] = new m()), this.events[t3].add(e3);
            }
            notify(t3, ...e3) {
              this.events[t3] && this.events[t3].notify(...e3);
            }
          } {
            sortInstanceNodePosition(t3, e3) {
              return 2 & t3.compareDocumentPosition(e3) ? 1 : -1;
            }
            getBaseTargetFromProps(t3, e3) {
              return t3.style ? t3.style[e3] : void 0;
            }
            removeValueFromRenderState(t3, { vars: e3, style: n3 }) {
              delete e3[t3], delete n3[t3];
            }
            makeTargetAnimatableFromInstance({ transition: t3, transitionEnd: e3, ...n3 }, { transformValues: s2 }, i2) {
              let o2 = function(t4, e4, n4) {
                const s3 = {};
                for (const i3 in t4) {
                  const t5 = St(i3, e4);
                  if (void 0 !== t5)
                    s3[i3] = t5;
                  else {
                    const t6 = n4.getValue(i3);
                    t6 && (s3[i3] = t6.get());
                  }
                }
                return s3;
              }(n3, t3 || {}, this);
              if (s2 && (e3 && (e3 = s2(e3)), n3 && (n3 = s2(n3)), o2 && (o2 = s2(o2))), i2) {
                !function(t5, e4, n4) {
                  var s3, i3;
                  const o3 = Object.keys(e4).filter((e5) => !t5.hasValue(e5)), r2 = o3.length;
                  var a2;
                  if (r2)
                    for (let c2 = 0; c2 < r2; c2++) {
                      const r3 = o3[c2], h2 = e4[r3];
                      let d2 = null;
                      Array.isArray(h2) && (d2 = h2[0]), null === d2 && (d2 = null !== (i3 = null !== (s3 = n4[r3]) && void 0 !== s3 ? s3 : t5.readValue(r3)) && void 0 !== i3 ? i3 : e4[r3]), null != d2 && ("string" == typeof d2 && (l(d2) || u(d2)) ? d2 = parseFloat(d2) : (a2 = d2, !yt.find(pt(a2)) && it.test(h2) && (d2 = mt(r3, h2))), t5.addValue(r3, S(d2, { owner: t5 })), void 0 === n4[r3] && (n4[r3] = d2), null !== d2 && t5.setBaseTarget(r3, d2));
                    }
                }(this, n3, o2);
                const t4 = ((t5, e4, n4, s3) => {
                  const i3 = function(t6, { ...e5 }, n5) {
                    const s4 = t6.current;
                    if (!(s4 instanceof Element))
                      return { target: e5, transitionEnd: n5 };
                    n5 && (n5 = { ...n5 }), t6.values.forEach((t7) => {
                      const e6 = t7.get();
                      if (!A(e6))
                        return;
                      const n6 = lo(e6, s4);
                      n6 && t7.set(n6);
                    });
                    for (const t7 in e5) {
                      const i4 = e5[t7];
                      if (!A(i4))
                        continue;
                      const o3 = lo(i4, s4);
                      o3 && (e5[t7] = o3, n5 || (n5 = {}), void 0 === n5[t7] && (n5[t7] = i4));
                    }
                    return { target: e5, transitionEnd: n5 };
                  }(t5, e4, s3);
                  return vo(t5, e4 = i3.target, n4, s3 = i3.transitionEnd);
                })(this, n3, o2, e3);
                e3 = t4.transitionEnd, n3 = t4.target;
              }
              return { transition: t3, transitionEnd: e3, ...n3 };
            }
          }
          class Vo extends Ao {
            readValueFromInstance(t3, e3) {
              if (Et.has(e3)) {
                const t4 = dt(e3);
                return t4 && t4.default || 0;
              }
              {
                const s2 = (n3 = t3, window.getComputedStyle(n3)), i2 = (E(e3) ? s2.getPropertyValue(e3) : s2[e3]) || 0;
                return "string" == typeof i2 ? i2.trim() : i2;
              }
              var n3;
            }
            measureInstanceViewportBox(t3, { transformPagePoint: e3 }) {
              return _s(t3, e3);
            }
            build(t3, e3, n3, s2) {
              xn(t3, e3, n3, s2.transformTemplate);
            }
            scrapeMotionValuesFromProps(t3, e3) {
              return Fn(t3, e3);
            }
            handleChildMotionValue() {
              this.childSubscription && (this.childSubscription(), delete this.childSubscription);
              const { children: t3 } = this.props;
              je(t3) && (this.childSubscription = t3.on("change", (t4) => {
                this.current && (this.current.textContent = `${t4}`);
              }));
            }
            renderInstance(t3, e3, n3, s2) {
              Ln(t3, e3, n3, s2);
            }
          }
          class Co extends Ao {
            constructor() {
              super(...arguments), this.isSVGTag = false;
            }
            getBaseTargetFromProps(t3, e3) {
              return t3[e3];
            }
            readValueFromInstance(t3, e3) {
              if (Et.has(e3)) {
                const t4 = dt(e3);
                return t4 && t4.default || 0;
              }
              return e3 = jn.has(e3) ? e3 : At(e3), t3.getAttribute(e3);
            }
            measureInstanceViewportBox() {
              return { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
            }
            scrapeMotionValuesFromProps(t3, e3) {
              return On(t3, e3);
            }
            build(t3, e3, n3, s2) {
              Mn(t3, e3, n3, this.isSVGTag, s2.transformTemplate);
            }
            renderInstance(t3, e3, n3, s2) {
              Bn(t3, e3, 0, s2);
            }
            mount(t3) {
              this.isSVGTag = Dn(t3.tagName), super.mount(t3);
            }
          }
          const Mo = (t3, e3) => mn(t3) ? new Co(e3, { enableHardwareAcceleration: false }) : new Vo(e3, { enableHardwareAcceleration: true }), Do = { ...ms, ...as, ...ro, layout: { ProjectionNode: oo, MeasureLayout: ai } }, ko = hn((t3, e3) => function(t4, { forwardMotionProps: e4 = false }, n3, s2) {
            return { ...mn(t4) ? $n : Wn, preloadedFeatures: n3, useRender: Rn(e4), createVisualElement: s2, Component: t4 };
          }(t3, e3, Do, Mo)), Ro = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], Lo = ({ className: n3, animateToNumber: s2, fontStyle: i2, transitions: o2, includeComma: r2, locale: l2 }) => {
            const u2 = e2().useRef(null), c2 = function(e3, { root: n4, margin: s3, amount: i3, once: o3 = false } = {}) {
              const [r3, l3] = (0, t2.useState)(false);
              return (0, t2.useEffect)(() => {
                if (!e3.current || o3 && r3)
                  return;
                const t3 = { root: n4 && n4.current || void 0, margin: s3, amount: i3 };
                return function(t4, e4, { root: n5, margin: s4, amount: i4 = "some" } = {}) {
                  const o4 = function(t5, e5, n6) {
                    if ("string" == typeof t5) {
                      t5 = document.querySelectorAll(t5);
                    } else
                      t5 instanceof Element && (t5 = [t5]);
                    return Array.from(t5 || []);
                  }(t4), r4 = /* @__PURE__ */ new WeakMap(), l4 = new IntersectionObserver((t5) => {
                    t5.forEach((t6) => {
                      const n6 = r4.get(t6.target);
                      if (t6.isIntersecting !== Boolean(n6))
                        if (t6.isIntersecting) {
                          const n7 = e4(t6);
                          "function" == typeof n7 ? r4.set(t6.target, n7) : l4.unobserve(t6.target);
                        } else
                          n6 && (n6(t6), r4.delete(t6.target));
                    });
                  }, { root: n5, rootMargin: s4, threshold: "number" == typeof i4 ? i4 : a[i4] });
                  return o4.forEach((t5) => l4.observe(t5)), () => l4.disconnect();
                }(e3.current, () => (l3(true), o3 ? void 0 : () => l3(false)), t3);
              }, [n4, e3, s3, o3]), r3;
            }(u2, { once: true }), h2 = function() {
              const t3 = We($e);
              return ze(t3.mount, []), t3;
            }(), d2 = e2().useRef(0), m2 = r2 ? Math.abs(s2).toLocaleString(l2 || "en-US") : String(Math.abs(s2)), p2 = Array.from(m2, Number).map((t3, e3) => isNaN(t3) ? m2[e3] : t3), [f2, g2] = e2().useState(0), [y2, v2] = e2().useState(0), x2 = e2().useRef(null);
            return e2().useEffect(() => {
              var t3;
              const e3 = null === (t3 = x2.current.getClientRects()) || void 0 === t3 ? void 0 : t3[0];
              e3 && (g2(e3.height), v2(e3.width));
            }, [s2, i2]), e2().useEffect(() => {
              c2 && h2.start("visible");
            }, [c2, s2]), e2().createElement("span", { ref: u2 }, 0 !== f2 && e2().createElement("div", { style: { display: "flex", flexDirection: "row", overflow: "hidden" }, className: n3 }, p2.map((t3, n4) => "string" == typeof t3 ? e2().createElement("div", { key: n4, style: { ...i2, fontVariantNumeric: "tabular-nums" } }, t3) : e2().createElement("div", { key: n4, style: { height: f2, width: y2 } }, Ro.map((t4) => e2().createElement(ko.div, { style: { ...i2, fontVariantNumeric: "tabular-nums" }, key: "" + d2.current++, initial: "hidden", variants: { hidden: { y: 0 }, visible: { y: f2 * p2[n4] * -1 - 20 * f2 } }, animate: h2, transition: null == o2 ? void 0 : o2(n4) }, t4))))), e2().createElement("div", { ref: x2, style: { position: "absolute", top: -9999, ...i2 } }, 0));
          }, jo = e2().memo(Lo, (t3, e3) => t3.animateToNumber === e3.animateToNumber && t3.fontStyle === e3.fontStyle && t3.includeComma === e3.includeComma);
        })(), i;
      })();
    });
  }
});
export default require_dist();
//# sourceMappingURL=react-animated-numbers.js.map
